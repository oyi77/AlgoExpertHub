# /build Command

Implement feature after spec verification.

## Usage

/build [feature-name]

## Purpose

Execute implementation ONLY after user has verified and approved the specs generated by `/sdd`.

## Prerequisites

**REQUIRED**:
- Requirements document exists: `.kiro/specs/[feature-name]/requirements.md`
- Design document exists: `.kiro/specs/[feature-name]/design.md`
- Tasks document exists: `.kiro/specs/[feature-name]/tasks.md`
- **User has approved specs** (explicit "yes" or confirmation)

## Workflow

1. **Load Specs**
   - Read all three spec documents
   - Understand requirements, design, and tasks
   - Review project patterns from `.kiro/steering/`

2. **Setup Task Tracking**
   - Check if `bd` (beads) is available
   - If yes: Create tasks in beads
     ```bash
     bd create "Task title" -t task -p 1 --json
     ```
   - If no: Use Cursor's task system
     ```javascript
     add_tasks([{ id, content, status: "PENDING" }])
     ```

3. **Implement Features**
   - Follow design architecture exactly
   - Implement tasks in order of dependencies
   - Update task status as you progress:
     - `PENDING` → `IN_PROGRESS` → `COMPLETE`
   - Write clean, maintainable code
   - Follow project conventions

4. **Verification**
   - Verify each task's acceptance criteria
   - Test implemented features
   - Update task status to COMPLETE when verified
   - Mark any blocked tasks with ERROR status

## Task Tracking Integration

### Using Beads (bd)

```bash
# Check availability
which bd

# Create task
bd create "Implement Stripe service" -t task -p 1 --json

# Update to in-progress
bd update bd-123 --status in_progress --json

# Mark complete
bd close bd-123 --reason "Completed and tested" --json
```

### Using Cursor Tasks

```javascript
// Create tasks
add_tasks([
  {
    id: "task_001",
    content: "Implement Stripe service",
    status: "PENDING"
  }
])

// Update progress
update_tasks([
  {
    id: "task_001",
    status: "IN_PROGRESS"
  }
])

// Complete
update_tasks([
  {
    id: "task_001",
    status: "COMPLETE"
  }
])
```

## Auto-Detection Logic

```javascript
// Check beads availability
const hasBeads = await checkCommand('which bd');

if (hasBeads) {
  // Use bd for task management
  await executeCommand('bd create ...');
} else {
  // Fallback to Cursor tasks
  await add_tasks([...]);
}
```

## Example

After user approves specs:

```
/build payment-gateway
```

This will:
1. Load specs from `.kiro/specs/payment-gateway/`
2. Detect task system (bd or Cursor)
3. Create tasks based on `tasks.md`
4. Implement features following `design.md`
5. Verify against `requirements.md`
6. Update task status throughout

## Output

- Implemented code following specs
- Updated task status
- Clean, tested features
- Documentation comments

## Best Practices

1. **Follow Design Exactly**: Don't deviate without updating specs first
2. **Update Tasks**: Keep task status current for transparency
3. **Verify Acceptance Criteria**: Check each criterion before marking complete
4. **Write Tests**: Ensure features work as specified
5. **Code Quality**: Follow project conventions from `.kiro/steering/`

## Error Handling

If requirements change during implementation:
1. STOP implementation
2. Use `/evolve [feature-name] [changes]`
3. Get user approval for updated specs
4. Resume implementation with updated design

## Integration Points

- Reads from `.kiro/specs/[feature-name]/`
- Follows patterns in `.kiro/steering/`
- Uses Laravel conventions
- Respects addon architecture
- Maintains code consistency

## Verification Checklist

Before marking feature complete:
- ✅ All tasks marked COMPLETE
- ✅ All acceptance criteria met
- ✅ Code follows design architecture
- ✅ Tests written and passing
- ✅ Documentation updated
- ✅ No deviation from approved specs
