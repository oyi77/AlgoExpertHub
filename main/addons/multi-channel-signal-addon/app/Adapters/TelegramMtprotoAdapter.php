<?php

namespace Addons\MultiChannelSignalAddon\App\Adapters;

use Addons\MultiChannelSignalAddon\App\Models\ChannelSource;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Log;
use function Amp\Future\await;
use function Amp\async;
use Revolt\EventLoop;
use Illuminate\Support\Facades\Storage;

/**
 * Telegram MTProto Adapter
 * 
 * Uses user account login (like Telethon) to access private channels.
 * Requires: danog/madelineproto
 */
class TelegramMtprotoAdapter extends BaseChannelAdapter
{
    /**
     * MadelineProto instance.
     *
     * @var \danog\MadelineProto\API|null
     */
    protected $madeline = null;

    /**
     * Session file path.
     *
     * @var string
     */
    protected $sessionFile;

    /**
     * Connect to Telegram using MTProto (user account).
     *
     * @param ChannelSource $channelSource
     * @return bool
     */
    public function connect(ChannelSource $channelSource): bool
    {
        try {
            $this->channelSource = $channelSource;
            $this->config = $channelSource->config ?? [];

            // Check if MadelineProto is available
            if (!class_exists('\danog\MadelineProto\API')) {
                $this->logError("MadelineProto library not installed. Run: composer require danog/madelineproto");
                return false;
            }

            $apiId = $this->getConfig('api_id');
            $apiHash = $this->getConfig('api_hash');

            if (empty($apiId) || empty($apiHash)) {
                $this->logError("API ID and API Hash are required for MTProto");
                return false;
            }

            // Session file path (per channel source)
            // Admin channels use separate namespace
            // v8 uses .madeline extension instead of .session
            if ($channelSource->isAdminOwned()) {
                $this->sessionFile = storage_path('app/madelineproto/admin/' . $channelSource->id . '.madeline');
            } else {
                $this->sessionFile = storage_path('app/madelineproto/' . $channelSource->id . '.madeline');
            }

            // Ensure directory exists
            $sessionDir = dirname($this->sessionFile);
            if (!is_dir($sessionDir)) {
                mkdir($sessionDir, 0755, true);
            }

            // Settings for MadelineProto v8
            // v8 uses Settings\AppInfo object instead of array
            $appInfo = new \danog\MadelineProto\Settings\AppInfo();
            $appInfo->setApiId((int) $apiId);
            $appInfo->setApiHash($apiHash);
            // Let MadelineProto auto-detect app_version to avoid UPDATE_APP_TO_LOGIN errors
            // app_version is auto-generated by MadelineProto based on its own version
            
            $settings = new \danog\MadelineProto\Settings();
            $settings->setAppInfo($appInfo);
            
            // Disable internal logging, use Laravel logs
            // Use CALLABLE_LOGGER with no-op function to disable logging
            $logger = new \danog\MadelineProto\Settings\Logger();
            $logger->setType(\danog\MadelineProto\Logger::CALLABLE_LOGGER);
            $logger->setExtra(function () {}); // No-op callable
            $settings->setLogger($logger);
            
            // Initialize MadelineProto v8
            $this->madeline = new \danog\MadelineProto\API($this->sessionFile, $settings);

            // CRITICAL: Don't call start() during GET requests in web context UNLESS session exists
            // start() outputs web UI HTML which we want to prevent
            // But if session file exists, we're already authenticated and can safely start
            $shouldStart = true;
            $sessionExists = file_exists($this->sessionFile);
            
            if (PHP_SAPI !== 'cli') {
                if (isset($_SERVER['REQUEST_METHOD']) && $_SERVER['REQUEST_METHOD'] === 'GET') {
                    // For GET requests, only start if session file exists (already authenticated)
                    // This allows authenticated users to access dialogs/channels via GET
                    $shouldStart = $sessionExists;
                } elseif (empty($_POST)) {
                    // For POST requests without data, check if session exists
                    // This handles cases where $_POST might be empty but we still need to connect
                    $shouldStart = $sessionExists || !empty($_POST);
                }
            }
            
            if (!$shouldStart) {
                // Don't initialize if we can't start
                $this->connected = false;
                return false;
            }
            
            // Start MadelineProto - this initializes the connection and handles auth if needed
            // According to docs: start() must be called to initialize the connection
            // v8 methods are async, so we need to await them
            // Ensure event loop is running for async operations
            // Use output buffering to prevent web UI output
            ob_start();
            ob_start();
            try {
                if (!EventLoop::getDriver()) {
                    EventLoop::run(function () {
                        $startResult = $this->madeline->start();
                        if ($startResult instanceof \Amp\Future) {
                            await([$startResult])[0];
                        }
                    });
                } else {
                    $startResult = $this->madeline->start();
                    if ($startResult instanceof \Amp\Future) {
                        await([$startResult])[0];
                    }
                }
                
                // Check if start() output HTML (password prompt)
                $output = '';
                while (ob_get_level() > 0) {
                    $output .= ob_get_clean();
                }
                
                // If output contains password form, password is required
                if (!empty($output) && (strpos($output, 'Enter your password') !== false || 
                    strpos($output, 'password') !== false ||
                    strpos($output, 'PASSWORD_HASH_INVALID') !== false)) {
                    // Extract password hint if available
                    $hint = '';
                    if (preg_match('/Hint:\s*([^<]+)/i', $output, $matches)) {
                        $hint = trim($matches[1]);
                    }
                    
                    // Store password requirement in config
                    $config = $this->channelSource->config;
                    $config['password_required'] = true;
                    if ($hint) {
                        $config['password_hint'] = $hint;
                    }
                    $this->channelSource->update(['config' => $config]);
                    
                    // Log that we detected password requirement
                    Log::info("Password requirement detected in connect()", [
                        'channel_id' => $this->channelSource->id,
                        'hint' => $hint,
                        'output_length' => strlen($output)
                    ]);
                    
                    $this->connected = false;
                    return false; // Connection failed - password required
                }
                
                // Disable automatic update handling (v8 uses setNoop() method)
                // Must be called after start()
                $this->madeline->setNoop();
            } catch (\Exception $e) {
                // Clear output buffers on error
                $output = '';
                while (ob_get_level() > 0) {
                    $output .= ob_get_clean();
                }
                
                // Check if error is password-related
                if (strpos($e->getMessage(), 'password') !== false || 
                    strpos($output, 'password') !== false ||
                    $e instanceof \danog\MadelineProto\RPCError\SessionPasswordNeededError) {
                    $config = $this->channelSource->config;
                    $config['password_required'] = true;
                    $this->channelSource->update(['config' => $config]);
                }
                
                // If start() fails, might need authentication
                $this->logError("MadelineProto start() failed: " . $e->getMessage());
                $this->connected = false;
                return false;
            }

            // Check if logged in
            try {
                if (!EventLoop::getDriver()) {
                    EventLoop::run(function () use (&$self) {
                        $selfResult = $this->madeline->getSelf();
                        if ($selfResult instanceof \Amp\Future) {
                            $self = await([$selfResult])[0];
                        } else {
                            $self = $selfResult;
                        }
                    });
                } else {
                    $selfResult = $this->madeline->getSelf();
                    if ($selfResult instanceof \Amp\Future) {
                        $self = await([$selfResult])[0];
                    } else {
                        $self = $selfResult;
                    }
                }
                if (!$self) {
                    // Not logged in, need authentication
                    Log::warning("connect() - getSelf() returned null", [
                        'channel_id' => $this->channelSource->id,
                        'session_file' => $this->sessionFile,
                        'session_exists' => file_exists($this->sessionFile)
                    ]);
                    $this->connected = false;
                    return false;
                }
                
                // Log successful connection
                Log::info("connect() - Successfully authenticated", [
                    'channel_id' => $this->channelSource->id,
                    'user_id' => $self['id'] ?? null,
                    'username' => $self['username'] ?? null
                ]);
            } catch (\Exception $e) {
                // getSelf() might throw if not authenticated
                Log::error("connect() - Authentication check failed", [
                    'channel_id' => $this->channelSource->id,
                    'error' => $e->getMessage(),
                    'session_file' => $this->sessionFile,
                    'session_exists' => file_exists($this->sessionFile)
                ]);
                $this->logError("Not authenticated: " . $e->getMessage());
                $this->connected = false;
                return false;
            }

            $this->connected = true;
            return true;

        } catch (\Exception $e) {
            $this->logError("Failed to connect via MTProto: " . $e->getMessage());
            return false;
        }
    }

    /**
     * Fetch messages from Telegram channel/group.
     *
     * @return Collection
     */
    public function fetchMessages(): Collection
    {
        if (!$this->connected && !$this->connect($this->channelSource)) {
            return collect();
        }

        $messages = collect();

        try {
            $channelUsername = $this->getConfig('channel_username');
            $channelId = $this->getConfig('channel_id');

            if (empty($channelUsername) && empty($channelId)) {
                $this->logError("Channel username or ID is required");
                return $messages;
            }

            // Resolve channel peer
            $peer = $channelUsername ?? $channelId;
            
            // Get channel entity
            // According to docs: getInfo() resolves peer to full info
            try {
                if (!EventLoop::getDriver()) {
                    EventLoop::run(function () use ($peer, &$channel) {
                        $infoResult = $this->madeline->getInfo($peer);
                        if ($infoResult instanceof \Amp\Future) {
                            $channel = await([$infoResult])[0];
                        } else {
                            $channel = $infoResult;
                        }
                    });
                } else {
                    $infoResult = $this->madeline->getInfo($peer);
                    if ($infoResult instanceof \Amp\Future) {
                        $channel = await([$infoResult])[0];
                    } else {
                        $channel = $infoResult;
                    }
                }
                $channelId = $channel['bot_api_id'] ?? $channel['id'] ?? null;

                if (!$channelId) {
                    $this->logError("Could not resolve channel: " . $peer);
                    return $messages;
                }
            } catch (\Exception $e) {
                $this->logError("Failed to get channel info for {$peer}: " . $e->getMessage());
                return $messages;
            }

            // Get last processed message ID
            $lastMessageId = $this->getConfig('last_message_id', 0);

            // Get messages from channel
            // According to docs: getHistory() parameters
            // offset_id: ID of message to start from (0 for latest)
            // min_id: Only return messages with ID >= min_id
            // offset_date: Only return messages sent before this date
            $params = [
                'peer' => $peer,
                'limit' => 100,
            ];

            // If we have a last message ID, fetch messages after it
            if ($lastMessageId > 0) {
                $params['min_id'] = $lastMessageId;
                $params['offset_id'] = 0; // Start from latest
            } else {
                // First fetch, get latest messages
                $params['offset_id'] = 0;
            }

            if (!EventLoop::getDriver()) {
                EventLoop::run(function () use ($params, &$result) {
                    $historyResult = $this->madeline->messages->getHistory($params);
                    if ($historyResult instanceof \Amp\Future) {
                        $result = await([$historyResult])[0];
                    } else {
                        $result = $historyResult;
                    }
                });
            } else {
                $historyResult = $this->madeline->messages->getHistory($params);
                if ($historyResult instanceof \Amp\Future) {
                    $result = await([$historyResult])[0];
                } else {
                    $result = $historyResult;
                }
            }

            if (isset($result['messages']) && is_array($result['messages'])) {
                foreach ($result['messages'] as $message) {
                    // Skip if already processed
                    if ($message['id'] <= $lastMessageId) {
                        continue;
                    }

                    // Extract message text
                    $messageText = $message['message'] ?? null;

                    if ($messageText) {
                        $messages->push([
                            'text' => $messageText,
                            'message_id' => $message['id'],
                            'date' => $message['date'] ?? now()->timestamp,
                            'from_id' => $message['from_id'] ?? null,
                            'peer_id' => $channelId,
                        ]);

                        // Update last message ID
                        $lastMessageId = max($lastMessageId, $message['id']);
                    }
                }
            }

            // Save last message ID
            if ($lastMessageId > 0) {
                $config = $this->channelSource->config;
                $config['last_message_id'] = $lastMessageId;
                $this->channelSource->update(['config' => $config]);
            }

        } catch (\Exception $e) {
            $this->logError("Failed to fetch MTProto messages: " . $e->getMessage());
        }

        return $messages;
    }

    /**
     * Fetch sample messages from a specific channel (for preview/parser creation).
     * This method fetches the latest N messages without filtering by last_message_id.
     *
     * @param string|int $channelId Channel ID or username
     * @param int $limit Number of messages to fetch (default: 20)
     * @return array Array with 'success' flag and 'messages' or 'error'
     */
    public function fetchSampleMessages($channelId, int $limit = 20): array
    {
        if (!$this->connected && !$this->connect($this->channelSource)) {
            return [
                'success' => false,
                'error' => 'Failed to connect to Telegram',
            ];
        }

        try {
            // Resolve channel peer
            $peer = $channelId;
            
            // Get channel entity
            try {
                if (!EventLoop::getDriver()) {
                    EventLoop::run(function () use ($peer, &$channel) {
                        $infoResult = $this->madeline->getInfo($peer);
                        if ($infoResult instanceof \Amp\Future) {
                            $channel = await([$infoResult])[0];
                        } else {
                            $channel = $infoResult;
                        }
                    });
                } else {
                    $infoResult = $this->madeline->getInfo($peer);
                    if ($infoResult instanceof \Amp\Future) {
                        $channel = await([$infoResult])[0];
                    } else {
                        $channel = $infoResult;
                    }
                }
            } catch (\Exception $e) {
                $this->logError("Failed to get channel info for {$peer}: " . $e->getMessage());
                return [
                    'success' => false,
                    'error' => 'Failed to resolve channel: ' . $e->getMessage(),
                ];
            }

            // Get latest messages (sample, not filtered by last_message_id)
            $params = [
                'peer' => $peer,
                'limit' => min($limit, 100), // Max 100 per request
                'offset_id' => 0, // Start from latest
            ];

            if (!EventLoop::getDriver()) {
                EventLoop::run(function () use ($params, &$result) {
                    $historyResult = $this->madeline->messages->getHistory($params);
                    if ($historyResult instanceof \Amp\Future) {
                        $result = await([$historyResult])[0];
                    } else {
                        $result = $historyResult;
                    }
                });
            } else {
                $historyResult = $this->madeline->messages->getHistory($params);
                if ($historyResult instanceof \Amp\Future) {
                    $result = await([$historyResult])[0];
                } else {
                    $result = $historyResult;
                }
            }

            $messages = [];
            if (isset($result['messages']) && is_array($result['messages'])) {
                foreach ($result['messages'] as $message) {
                    // Extract message text
                    $messageText = $message['message'] ?? null;

                    if ($messageText) {
                        $messages[] = [
                            'text' => $messageText,
                            'message_id' => $message['id'],
                            'date' => $message['date'] ?? now()->timestamp,
                            'from_id' => $message['from_id'] ?? null,
                            'formatted_date' => isset($message['date']) 
                                ? date('Y-m-d H:i:s', $message['date']) 
                                : now()->format('Y-m-d H:i:s'),
                        ];
                    }
                }
            }

            return [
                'success' => true,
                'messages' => $messages,
                'count' => count($messages),
            ];

        } catch (\Exception $e) {
            $this->logError("Failed to fetch sample messages: " . $e->getMessage());
            return [
                'success' => false,
                'error' => 'Failed to fetch messages: ' . $e->getMessage(),
            ];
        }
    }

    /**
     * Validate channel configuration.
     *
     * @param array $config
     * @return bool
     */
    public function validateConfig(array $config): bool
    {
        if (empty($config['api_id']) || empty($config['api_hash'])) {
            return false;
        }

        // Validate API ID is numeric
        if (!is_numeric($config['api_id'])) {
            return false;
        }

        return true;
    }

    /**
     * Get the adapter type.
     *
     * @return string
     */
    public function getType(): string
    {
        return 'telegram_mtproto';
    }

    /**
     * Start authentication process.
     * Returns QR code or phone number request.
     *
     * @return array
     */
    public function startAuth(): array
    {
        // CRITICAL: This method should ONLY be called during POST requests
        // If called during GET, it will output web UI via start()
        // Check if we're in a web context and this is a GET request
        $isGetRequest = false;
        if (PHP_SAPI !== 'cli') {
            // Check multiple ways to detect GET request
            if (isset($_SERVER['REQUEST_METHOD']) && $_SERVER['REQUEST_METHOD'] === 'GET') {
                $isGetRequest = true;
            } elseif (isset($_SERVER['REQUEST_METHOD']) && $_SERVER['REQUEST_METHOD'] !== 'POST') {
                $isGetRequest = true;
            } elseif (!isset($_POST) || empty($_POST)) {
                // If no POST data and we're in web context, assume GET
                $isGetRequest = true;
            }
        }
        
        if ($isGetRequest) {
            // Don't initialize MadelineProto during GET requests
            // This prevents start() from being called and outputting web UI
            return [
                'type' => 'phone_required',
                'message' => 'Please submit the form to start authentication'
            ];
        }
        
        try {
            if (!class_exists('\danog\MadelineProto\API')) {
                return [
                    'type' => 'error',
                    'message' => 'MadelineProto not installed'
                ];
            }

            $apiId = $this->getConfig('api_id');
            $apiHash = $this->getConfig('api_hash');

            if (empty($apiId) || empty($apiHash)) {
                return [
                    'type' => 'error',
                    'message' => 'API ID and API Hash required'
                ];
            }

            // CRITICAL: Set programmatic auth mode BEFORE initializing MadelineProto
            // This prevents start() from outputting web UI
            putenv('MADELINE_PROGRAMMATIC_AUTH=1');
            $_ENV['MADELINE_PROGRAMMATIC_AUTH'] = '1';
            
            // Also set in $_SERVER for compatibility
            $_SERVER['MADELINE_PROGRAMMATIC_AUTH'] = '1';

            // Session file path (per channel source)
            // Admin channels use separate namespace
            if ($this->channelSource->isAdminOwned()) {
                $this->sessionFile = storage_path('app/madelineproto/admin/' . $this->channelSource->id . '.madeline');
            } else {
                $this->sessionFile = storage_path('app/madelineproto/' . $this->channelSource->id . '.madeline');
            }
            
            $sessionDir = dirname($this->sessionFile);
            if (!is_dir($sessionDir)) {
                mkdir($sessionDir, 0755, true);
            }

            // Settings for MadelineProto v8
            $appInfo = new \danog\MadelineProto\Settings\AppInfo();
            $appInfo->setApiId((int) $apiId);
            $appInfo->setApiHash($apiHash);
            
            $settings = new \danog\MadelineProto\Settings();
            $settings->setAppInfo($appInfo);
            
            // Disable internal logging, use Laravel logs
            // Use CALLABLE_LOGGER with no-op function to disable logging
            $logger = new \danog\MadelineProto\Settings\Logger();
            $logger->setType(\danog\MadelineProto\Logger::CALLABLE_LOGGER);
            $logger->setExtra(function () {}); // No-op callable
            $settings->setLogger($logger);
            
            $this->madeline = new \danog\MadelineProto\API($this->sessionFile, $settings);
            
            // Store original POST data (including CSRF token for Laravel)
            $originalPost = $_POST ?? [];
            $csrfToken = $originalPost['_token'] ?? null;
            
            // CRITICAL: Get phone number BEFORE calling start()
            // We need it to call phoneLogin() directly without triggering web UI
            $phone = $this->getConfig('phone_number');

            if (empty($phone)) {
                // Request phone number
                return [
                    'type' => 'phone_required',
                    'message' => 'Phone number required'
                ];
            }
            
            // CRITICAL: The issue is that start() outputs HTML when called in web context
            // phoneLogin() internally uses methodCallAsyncRead() which should work without start()
            // BUT: methodCallAsyncRead() might trigger initialization which calls start()
            // SOLUTION: Use the MTProto API's methodCallAsyncRead() directly, bypassing the wrapper
            
            // Clear $_POST to prevent start() from detecting web context
            // But preserve CSRF token for Laravel validation
            $_POST = [];
            if ($csrfToken) {
                $_POST['_token'] = $csrfToken;
            }
            
            // Use output buffering to catch any output (though getOutputBufferStream() bypasses this)
            ob_start();
            ob_start();
            ob_start();
            
            try {
                // CRITICAL: Check authorization state before calling phoneLogin()
                // If already logged in, we need to logout first or skip phoneLogin()
                $sentCode = null;
                if (!EventLoop::getDriver()) {
                    EventLoop::run(function () use ($phone, &$sentCode) {
                        // Call phoneLogin() - it will check if already logged in internally
                        // If it throws "already logged in" exception, logout and retry
                        try {
                            $result = $this->madeline->phoneLogin($phone);
                        } catch (\danog\MadelineProto\Exception $e) {
                            // If already logged in, logout first and retry
                            if (strpos($e->getMessage(), 'already logged') !== false || 
                                strpos($e->getMessage(), 'already_loggedIn') !== false) {
                                Log::info("API already logged in, logging out to start fresh authentication");
                                try {
                                    $this->madeline->logout();
                                    // Retry phoneLogin after logout
                                    $result = $this->madeline->phoneLogin($phone);
                                } catch (\Exception $logoutError) {
                                    Log::error("Failed to logout and retry: " . $logoutError->getMessage());
                                    throw $e; // Re-throw original exception
                                }
                            } else {
                                throw $e; // Re-throw if it's a different error
                            }
                        }
                        
                        // Log what we got for debugging
                        Log::debug("phoneLogin() result type", [
                            'type' => gettype($result),
                            'is_array' => is_array($result),
                            'is_future' => $result instanceof \Amp\Future,
                            'has_underscore' => is_array($result) && isset($result['_'])
                        ]);
                        
                        // If it's already an array (synchronous), use it
                        if (is_array($result) && isset($result['_'])) {
                            $sentCode = $result;
                        } elseif ($result instanceof \Amp\Future) {
                            // It's a Future, await it
                            $sentCode = await([$result])[0];
                        } else {
                            // Unexpected type, use as-is
                            $sentCode = $result;
                        }
                    });
                } else {
                    // We're already in an event loop context
                    // Call phoneLogin() - it will check if already logged in internally
                    // If it throws "already logged in" exception, logout and retry
                    try {
                        $result = $this->madeline->phoneLogin($phone);
                    } catch (\danog\MadelineProto\Exception $e) {
                        // If already logged in, logout first and retry
                        if (strpos($e->getMessage(), 'already logged') !== false || 
                            strpos($e->getMessage(), 'already_loggedIn') !== false) {
                            Log::info("API already logged in, logging out to start fresh authentication");
                            try {
                                $this->madeline->logout();
                                // Retry phoneLogin after logout
                                $result = $this->madeline->phoneLogin($phone);
                            } catch (\Exception $logoutError) {
                                Log::error("Failed to logout and retry: " . $logoutError->getMessage());
                                throw $e; // Re-throw original exception
                            }
                        } else {
                            throw $e; // Re-throw if it's a different error
                        }
                    }
                    
                    // Log what we got for debugging
                    Log::debug("phoneLogin() result type", [
                        'type' => gettype($result),
                        'is_array' => is_array($result),
                        'is_future' => $result instanceof \Amp\Future,
                        'has_underscore' => is_array($result) && isset($result['_'])
                    ]);
                    
                    // If it's already an array (synchronous), use it
                    if (is_array($result) && isset($result['_'])) {
                        $sentCode = $result;
                    } elseif ($result instanceof \Amp\Future) {
                        // It's a Future, await it
                        $sentCode = await([$result])[0];
                    } else {
                        // Unexpected type, use as-is
                        $sentCode = $result;
                    }
                }
                
                // Restore original POST
                $_POST = $originalPost;
                
                // Clear all output buffers
                while (ob_get_level() > 0) {
                    @ob_end_clean();
                }
                
                // Disable automatic update handling (v8 uses setNoop() method)
                try {
                    $this->madeline->setNoop();
                } catch (\Exception $e) {
                    // setNoop() might fail if not initialized, that's okay
                    Log::debug("setNoop() failed: " . $e->getMessage());
                }
                
                // Handle response from phoneLogin
                // phoneLogin() returns the authorization object directly (auth.sentCode)
                // It sets $this->authorized = WAITING_CODE internally
                if (isset($sentCode['_'])) {
                    // Check if it's a sentCode object (this is what phoneLogin() returns)
                    if ($sentCode['_'] === 'auth.sentCode' || isset($sentCode['phone_code_hash'])) {
                        return [
                            'type' => 'code_required',
                            'message' => 'Enter verification code',
                            'phone_code_hash' => $sentCode['phone_code_hash'] ?? null,
                            'sent_code' => $sentCode
                        ];
                    }
                    // Check if already authorized (shouldn't happen, but handle it)
                    if ($sentCode['_'] === 'auth.authorization') {
                        // Already logged in somehow
                        $self = null;
                        try {
                            if (!EventLoop::getDriver()) {
                                EventLoop::run(function () use (&$self) {
                                    $self = await($this->madeline->getSelf());
                                });
                            } else {
                                $self = await($this->madeline->getSelf());
                            }
                            $this->connected = true;
                            return [
                                'type' => 'success',
                                'message' => 'Already authenticated',
                                'user' => $self
                            ];
                        } catch (\Exception $e) {
                            // getSelf() failed, return error
                            return [
                                'type' => 'error',
                                'message' => 'Authentication state unclear: ' . $e->getMessage()
                            ];
                        }
                    }
                }
                
                // Fallback: check for phone_code_hash in response
                if (isset($sentCode['phone_code_hash'])) {
                    return [
                        'type' => 'code_required',
                        'message' => 'Enter verification code',
                        'phone_code_hash' => $sentCode['phone_code_hash']
                    ];
                }
                
                // If we get here, the response is unexpected
                Log::warning("Unexpected phoneLogin() response", ['response' => $sentCode]);
                return [
                    'type' => 'error',
                    'message' => 'Unexpected response from Telegram: ' . json_encode($sentCode)
                ];
                
            } catch (\Exception $e) {
                // Restore original POST
                $_POST = $originalPost;
                
                // Clear all output buffers even on error
                while (ob_get_level() > 0) {
                    @ob_end_clean();
                }
                
                $errorMessage = $e->getMessage();
                
                // If phoneLogin() fails because start() wasn't called, we have a problem
                // phoneLogin() might require start() to be called first
                // But calling start() will output HTML, which we're trying to avoid
                // This is a catch-22 situation
                
                Log::error("MadelineProto phoneLogin error (tried without start()): " . $errorMessage, [
                    'exception' => $e,
                    'api_id' => $apiId,
                    'phone' => substr($phone, 0, 3) . '***'
                ]);
                
                // Check if error indicates we need to call start() first
                if (strpos($errorMessage, 'not started') !== false || 
                    strpos($errorMessage, 'not initialized') !== false ||
                    strpos($errorMessage, 'must be called') !== false) {
                    // phoneLogin() requires start() to be called first
                    // But start() will output HTML, so we can't use it
                    // Return an error explaining the situation
                    return [
                        'type' => 'error',
                        'message' => 'MadelineProto requires initialization, but this would trigger a web UI. Please ensure your session file is valid or use CLI authentication.'
                    ];
                }
                
                // Check for UPDATE_APP_TO_LOGIN error
                if (strpos($errorMessage, 'UPDATE_APP_TO_LOGIN') !== false) {
                    $helpMessage = 'UPDATE_APP_TO_LOGIN Error: Your API credentials appear to be tied to an outdated API layer. ';
                    $helpMessage .= 'Please create a new application at https://my.telegram.org/apps and use the new API ID and API Hash.';
                    return [
                        'type' => 'error',
                        'message' => $helpMessage
                    ];
                }
                
                if (strpos($errorMessage, 'PHONE_NUMBER_INVALID') !== false) {
                    return [
                        'type' => 'error',
                        'message' => 'Invalid phone number format. Please use international format (e.g., +1234567890).'
                    ];
                }
                
                return [
                    'type' => 'error',
                    'message' => 'Failed to send verification code: ' . $errorMessage . '. Please check your API credentials and phone number format.'
                ];
            }
        } catch (\Exception $e) {
            // Restore original POST
            $_POST = $originalPost ?? [];
            
            // Clear all output buffers
            while (ob_get_level() > 0) {
                @ob_end_clean();
            }
            
            Log::error("startAuth() outer exception: " . $e->getMessage(), [
                'exception' => $e,
                'trace' => $e->getTraceAsString()
            ]);
            
            return [
                'type' => 'error',
                'message' => 'Authentication failed: ' . $e->getMessage()
            ];
        }
    }

    /**
     * Complete authentication with verification code.
     *
     * @param string $code
     * @param string $phoneCodeHash
     * @return array
     */
    public function completeAuth(string $code, string $phoneCodeHash): array
    {
        try {
            // CRITICAL: Refresh channel source and config to ensure we have latest data
            $this->channelSource->refresh();
            $this->config = $this->channelSource->config ?? [];
            
            // Log config for debugging
            Log::info("TelegramMtprotoAdapter::completeAuth - Config check", [
                'channel_id' => $this->channelSource->id,
                'config_keys' => array_keys($this->config),
                'has_phone_number' => isset($this->config['phone_number']),
                'phone_number' => $this->config['phone_number'] ?? 'NOT SET',
                'raw_config' => $this->config
            ]);
            
            // CRITICAL: Ensure MadelineProto API is initialized
            // If not initialized, we need to create it (but don't call start() which outputs HTML)
            if (!$this->madeline) {
                // Initialize the API instance without calling start()
                $apiId = $this->getConfig('api_id');
                $apiHash = $this->getConfig('api_hash');

                if (empty($apiId) || empty($apiHash)) {
                    return [
                        'type' => 'error',
                        'message' => 'API ID and API Hash required'
                    ];
                }

                // Session file path
                if ($this->channelSource->isAdminOwned()) {
                    $this->sessionFile = storage_path('app/madelineproto/admin/' . $this->channelSource->id . '.madeline');
                } else {
                    $this->sessionFile = storage_path('app/madelineproto/' . $this->channelSource->id . '.madeline');
                }
                
                $sessionDir = dirname($this->sessionFile);
                if (!is_dir($sessionDir)) {
                    mkdir($sessionDir, 0755, true);
                }

                // Settings for MadelineProto v8
                $appInfo = new \danog\MadelineProto\Settings\AppInfo();
                $appInfo->setApiId((int) $apiId);
                $appInfo->setApiHash($apiHash);
                
                $settings = new \danog\MadelineProto\Settings();
                $settings->setAppInfo($appInfo);
                
                // Disable internal logging
                $logger = new \danog\MadelineProto\Settings\Logger();
                $logger->setType(\danog\MadelineProto\Logger::CALLABLE_LOGGER);
                $logger->setExtra(function () {});
                $settings->setLogger($logger);
                
                $this->madeline = new \danog\MadelineProto\API($this->sessionFile, $settings);
            }

            // CRITICAL: completePhoneLogin() requires the authorization state from phoneLogin()
            // It checks $this->authorized === WAITING_CODE and uses $this->authorization['phone_code_hash']
            // Since we're using a new adapter instance, we need to use the lower-level API method directly
            // Use auth.signIn directly with the phone_code_hash we stored in the session
            
            // Get phone number from config
            $phone = $this->getConfig('phone_number');
            if (empty($phone)) {
                // Log detailed error for debugging
                Log::error("Phone number not found in config", [
                    'channel_id' => $this->channelSource->id,
                    'config_keys' => array_keys($this->config),
                    'full_config' => $this->config,
                    'channel_source_config' => $this->channelSource->config
                ]);
                
                return [
                    'type' => 'error',
                    'message' => 'Phone number not found in config. Please go back and re-enter your phone number.'
                ];
            }
            
            // CRITICAL: completePhoneLogin() requires authorization state from phoneLogin()
            // We need to set up the authorization state manually before calling completePhoneLogin()
            // Both authorized and authorization are public properties in MTProto trait
            // completePhoneLogin() calls async methods internally, so we need to run it in async context
            $authorization = null;
            try {
                // Always run in async context since completePhoneLogin() calls async methods
                if (!EventLoop::getDriver()) {
                    EventLoop::run(function () use ($phone, $code, $phoneCodeHash, &$authorization) {
                        // Set up authorization state - both are public properties in MTProto trait
                        $this->madeline->authorized = \danog\MadelineProto\API::WAITING_CODE;
                        $this->madeline->authorization = [
                            'phone_number' => $phone,
                            'phone_code_hash' => $phoneCodeHash,
                            '_' => 'auth.sentCode' // Required structure
                        ];
                        
                        // completePhoneLogin() calls async methods internally but returns array synchronously
                        $authorization = $this->madeline->completePhoneLogin($code);
                    });
                } else {
                    // EventLoop driver exists, but we still need async context for completePhoneLogin()
                    // Use async() helper to run in async context - async() returns a Future
                    $future = async(function () use ($phone, $code, $phoneCodeHash) {
                        // Set up authorization state
                        $this->madeline->authorized = \danog\MadelineProto\API::WAITING_CODE;
                        $this->madeline->authorization = [
                            'phone_number' => $phone,
                            'phone_code_hash' => $phoneCodeHash,
                            '_' => 'auth.sentCode'
                        ];
                        
                        // completePhoneLogin() calls async methods internally but returns array synchronously
                        return $this->madeline->completePhoneLogin($code);
                    });
                    
                    // Await the Future - await() expects array, so wrap it
                    $authorization = await([$future])[0];
                }
            } catch (\danog\MadelineProto\RPCError\SessionPasswordNeededError $e) {
                // Handle 2FA password requirement
                // The authorization object should contain password info
                $hint = '';
                try {
                    // Try to get hint from authorization if available
                    if (isset($this->madeline->authorization['hint'])) {
                        $hint = $this->madeline->authorization['hint'];
                    }
                } catch (\Exception $e2) {
                    // Ignore - hint not critical
                }
                
                return [
                    'type' => 'password_required',
                    'message' => 'Two-factor authentication is enabled. Password required.',
                    'hint' => $hint,
                    'has_recovery' => false,
                ];
            } catch (\danog\MadelineProto\RPCErrorException $e) {
                // Handle 2FA (SESSION_PASSWORD_NEEDED) - fallback check
                if ($e->rpc === 'SESSION_PASSWORD_NEEDED') {
                    $hint = '';
                    try {
                        // Try to get hint from authorization if available
                        if (isset($this->madeline->authorization['hint'])) {
                            $hint = $this->madeline->authorization['hint'];
                        }
                    } catch (\Exception $e2) {
                        // Ignore - hint not critical
                    }
                    
                    return [
                        'type' => 'password_required',
                        'message' => 'Two-factor authentication is enabled. Password required.',
                        'hint' => $hint,
                        'has_recovery' => false,
                    ];
                }
                // Handle PHONE_NUMBER_UNOCCUPIED (signup required)
                if ($e->rpc === 'PHONE_NUMBER_UNOCCUPIED') {
                    return [
                        'type' => 'signup_required',
                        'message' => 'Account signup required. Please use Telegram app to complete signup.'
                    ];
                }
                // Re-throw other RPC errors
                throw $e;
            }
            
            // Handle special cases (signup required, etc.)
            // These are handled by completePhoneLogin() but we need to handle them manually
            if (isset($authorization['_'])) {
                if ($authorization['_'] === 'auth.authorizationSignUpRequired' || 
                    $authorization['_'] === 'account.needSignup') {
                    return [
                        'type' => 'signup_required',
                        'message' => 'Account signup required. Please use Telegram app to complete signup.',
                        'authorization' => $authorization
                    ];
                }
            }

            // If completePhoneLogin() succeeded, it means authentication was successful
            // The authorization object contains user info, so we can use it directly
            // Try to get user info from authorization or getSelf()
            $userInfo = null;
            
            // Check if authorization contains user info
            if (isset($authorization['user'])) {
                $userInfo = $authorization['user'];
            } elseif (isset($authorization['authorization']['user'])) {
                $userInfo = $authorization['authorization']['user'];
            } else {
                // Try to get user info via getSelf() if needed
                try {
                    if (!EventLoop::getDriver()) {
                        EventLoop::run(function () use (&$userInfo) {
                            $selfResult = $this->madeline->getSelf();
                            if ($selfResult instanceof \Amp\Future) {
                                $userInfo = await([$selfResult])[0];
                            } else {
                                $userInfo = $selfResult;
                            }
                        });
                    } else {
                        $selfResult = $this->madeline->getSelf();
                        if ($selfResult instanceof \Amp\Future) {
                            $userInfo = await([$selfResult])[0];
                        } else {
                            $userInfo = $selfResult;
                        }
                    }
                } catch (\Exception $e) {
                    Log::warning("Could not get user info via getSelf(): " . $e->getMessage());
                    // Continue without user info - authentication still succeeded
                }
            }

            // Authentication succeeded (completePhoneLogin() returned successfully)
            $this->connected = true;

            // Ensure session is saved (MadelineProto v8 auto-saves, but we can force it)
            // The session file is automatically updated when authentication completes
            // No explicit save needed in v8 - it's handled internally
            
            // Update config with authenticated user
            $config = $this->channelSource->config;
            $config['authenticated'] = true;
            if ($userInfo) {
                $config['user_id'] = $userInfo['id'] ?? $userInfo['user']['id'] ?? null;
                $config['username'] = $userInfo['username'] ?? $userInfo['user']['username'] ?? null;
            }
            $this->channelSource->update(['config' => $config]);
            
            // Log successful authentication
            Log::info("Authentication completed successfully", [
                'channel_id' => $this->channelSource->id,
                'session_file' => $this->sessionFile,
                'has_user_info' => !empty($userInfo),
                'user_id' => $config['user_id'] ?? null
            ]);

            return [
                'type' => 'success',
                'message' => 'Authentication successful',
                'user' => $userInfo ?? $authorization
            ];

        } catch (\Exception $e) {
            $errorMessage = $e->getMessage();
            
            // Handle specific error cases
            if (strpos($errorMessage, 'PHONE_CODE_INVALID') !== false) {
                return [
                    'type' => 'error',
                    'message' => 'Invalid verification code. Please try again.'
                ];
            }
            
            if (strpos($errorMessage, 'PHONE_CODE_EXPIRED') !== false) {
                return [
                    'type' => 'error',
                    'message' => 'Verification code expired. Please request a new code.'
                ];
            }

            return [
                'type' => 'error',
                'message' => 'Authentication failed: ' . $errorMessage
            ];
        }
    }

    /**
     * Complete password authentication (2FA).
     *
     * @param string $password
     * @return array
     */
    public function completePasswordAuth(string $password): array
    {
        // Use output buffering to prevent MadelineProto web UI output
        ob_start();
        ob_start();
        ob_start();
        
        try {
            // Ensure MadelineProto is initialized and started
            if (!$this->madeline) {
                // Initialize with proper settings
                $this->channelSource->refresh();
                $this->config = $this->channelSource->config ?? [];
                
                $apiId = $this->getConfig('api_id');
                $apiHash = $this->getConfig('api_hash');
                
                if (empty($apiId) || empty($apiHash)) {
                    while (ob_get_level() > 0) {
                        @ob_end_clean();
                    }
                    return [
                        'type' => 'error',
                        'message' => 'API ID and API Hash required'
                    ];
                }
                
                // Session file path
                if ($this->channelSource->isAdminOwned()) {
                    $this->sessionFile = storage_path('app/madelineproto/admin/' . $this->channelSource->id . '.madeline');
                } else {
                    $this->sessionFile = storage_path('app/madelineproto/' . $this->channelSource->id . '.madeline');
                }
                
                // Ensure directory exists
                $sessionDir = dirname($this->sessionFile);
                if (!is_dir($sessionDir)) {
                    mkdir($sessionDir, 0755, true);
                }
                
                // Settings for MadelineProto v8
                $appInfo = new \danog\MadelineProto\Settings\AppInfo();
                $appInfo->setApiId((int) $apiId);
                $appInfo->setApiHash($apiHash);
                
                $settings = new \danog\MadelineProto\Settings();
                $settings->setAppInfo($appInfo);
                
                // Disable internal logging
                $logger = new \danog\MadelineProto\Settings\Logger();
                $logger->setType(\danog\MadelineProto\Logger::CALLABLE_LOGGER);
                $logger->setExtra(function () {});
                $settings->setLogger($logger);
                
                // Initialize MadelineProto v8
                $this->madeline = new \danog\MadelineProto\API($this->sessionFile, $settings);
            }
            
            // Ensure start() is called to initialize session (but suppress output)
            // This is required before complete2faLogin() can work
            if (!$this->connected) {
                try {
                    $sessionExists = file_exists($this->sessionFile);
                    if ($sessionExists) {
                        // Start MadelineProto but suppress output
                        if (!EventLoop::getDriver()) {
                            EventLoop::run(function () {
                                $startResult = $this->madeline->start();
                                if ($startResult instanceof \Amp\Future) {
                                    await([$startResult])[0];
                                }
                            });
                        } else {
                            $startResult = $this->madeline->start();
                            if ($startResult instanceof \Amp\Future) {
                                await([$startResult])[0];
                            }
                        }
                        
                        // Clear any output
                        while (ob_get_level() > 0) {
                            @ob_get_clean();
                        }
                    }
                } catch (\Exception $e) {
                    // If start fails, continue anyway - might need password
                    Log::debug("start() failed in completePasswordAuth (expected if password needed): " . $e->getMessage());
                }
            }

            if (!$this->madeline) {
                while (ob_get_level() > 0) {
                    @ob_end_clean();
                }
                return [
                    'type' => 'error',
                    'message' => 'MadelineProto not initialized. Please start authentication first.'
                ];
            }

            // Set programmatic auth mode to prevent web UI
            putenv('MADELINE_PROGRAMMATIC_AUTH=1');
            $_ENV['MADELINE_PROGRAMMATIC_AUTH'] = '1';
            $_SERVER['MADELINE_PROGRAMMATIC_AUTH'] = '1';
            $_POST['type'] = 'password';
            $_POST['password'] = $password;

            // Ensure authorization state is set to WAITING_PASSWORD
            // This is required before calling complete2faLogin()
            // The authorization state should already be set from completePhoneLogin()
            // when it detected password requirement
            try {
                // Set authorization state to WAITING_PASSWORD if not already set
                if (!isset($this->madeline->authorized) || 
                    $this->madeline->authorized !== \danog\MadelineProto\API::WAITING_PASSWORD) {
                    $this->madeline->authorized = \danog\MadelineProto\API::WAITING_PASSWORD;
                }
                
                // Ensure authorization object exists
                if (!isset($this->madeline->authorization) || empty($this->madeline->authorization)) {
                    // Get hint from config if available
                    $hint = $this->channelSource->config['password_hint'] ?? '';
                    $this->madeline->authorization = [
                        'hint' => $hint,
                        '_' => 'account.password'
                    ];
                }
            } catch (\Exception $e) {
                // If setting state fails, try to continue anyway
                Log::warning("Could not set password authorization state: " . $e->getMessage());
            }

            // Complete 2FA login with password
            $authorization = null;
            try {
                if (!EventLoop::getDriver()) {
                    EventLoop::run(function () use ($password, &$authorization) {
                        $authorization = $this->madeline->complete2faLogin($password);
                    });
                } else {
                    $future = async(function () use ($password) {
                        return $this->madeline->complete2faLogin($password);
                    });
                    $authorization = await([$future])[0];
                }
            } catch (\danog\MadelineProto\RPCErrorException $e) {
                // Clear output buffers first
                $output = '';
                while (ob_get_level() > 0) {
                    $output .= ob_get_clean();
                }
                
                if ($e->rpc === 'PASSWORD_HASH_INVALID') {
                    return [
                        'type' => 'error',
                        'message' => 'Invalid password. Please try again.'
                    ];
                }
                
                // Check output for password errors even if exception doesn't match
                if (!empty($output) && strpos($output, 'PASSWORD_HASH_INVALID') !== false) {
                    return [
                        'type' => 'error',
                        'message' => 'Invalid password. Please try again.'
                    ];
                }
                
                throw $e;
            } catch (\Exception $e) {
                // Clear output buffers
                $output = '';
                while (ob_get_level() > 0) {
                    $output .= ob_get_clean();
                }
                
                // Check if output contains password error
                if (!empty($output) && (strpos($output, 'PASSWORD_HASH_INVALID') !== false || 
                    strpos($output, 'ERROR: PASSWORD_HASH_INVALID') !== false)) {
                    return [
                        'type' => 'error',
                        'message' => 'Invalid password. Please try again.'
                    ];
                }
                
                if (strpos($e->getMessage(), 'PASSWORD_HASH_INVALID') !== false) {
                    return [
                        'type' => 'error',
                        'message' => 'Invalid password. Please try again.'
                    ];
                }
                
                throw $e;
            }
            
            // Clear any remaining output buffers AFTER successful authentication
            $output = '';
            while (ob_get_level() > 0) {
                $output .= ob_get_clean();
            }
            
            // Log if web UI was suppressed (shouldn't happen on success)
            if (!empty($output) && (strpos($output, '<html') !== false || strpos($output, 'MadelineProto') !== false)) {
                Log::warning("MadelineProto web UI output suppressed in completePasswordAuth (after success)", [
                    'output_length' => strlen($output),
                    'contains_password_error' => strpos($output, 'PASSWORD_HASH_INVALID') !== false
                ]);
            }

            // Get user info
            $userInfo = null;
            try {
                if (!EventLoop::getDriver()) {
                    EventLoop::run(function () use (&$userInfo) {
                        $selfResult = $this->madeline->getSelf();
                        if ($selfResult instanceof \Amp\Future) {
                            $userInfo = await([$selfResult])[0];
                        } else {
                            $userInfo = $selfResult;
                        }
                    });
                } else {
                    $selfResult = $this->madeline->getSelf();
                    if ($selfResult instanceof \Amp\Future) {
                        $userInfo = await([$selfResult])[0];
                    } else {
                        $userInfo = $selfResult;
                    }
                }
            } catch (\Exception $e) {
                Log::warning("Could not get user info via getSelf(): " . $e->getMessage());
            }

            $this->connected = true;

            // Update config
            $config = $this->channelSource->config;
            $config['authenticated'] = true;
            unset($config['password_required']); // Remove password requirement flag
            if ($userInfo) {
                $config['user_id'] = $userInfo['id'] ?? $userInfo['user']['id'] ?? null;
                $config['username'] = $userInfo['username'] ?? $userInfo['user']['username'] ?? null;
            }
            $this->channelSource->update(['config' => $config]);

            Log::info("Password authentication completed successfully", [
                'channel_id' => $this->channelSource->id,
            ]);

            return [
                'type' => 'success',
                'message' => 'Authentication completed successfully',
                'user' => $userInfo
            ];
        } catch (\Exception $e) {
            // Final buffer clear on any exception
            $output = '';
            while (ob_get_level() > 0) {
                $output .= ob_get_clean();
            }
            
            // Check if HTML was output (password error)
            if (!empty($output) && (strpos($output, 'PASSWORD_HASH_INVALID') !== false || 
                strpos($output, 'ERROR: PASSWORD_HASH_INVALID') !== false)) {
                return [
                    'type' => 'error',
                    'message' => 'Invalid password. Please try again.'
                ];
            }
            
            $this->logError("Password authentication failed: " . $e->getMessage());
            return [
                'type' => 'error',
                'message' => 'Password authentication failed: ' . $e->getMessage()
            ];
        } finally {
            // Ensure all buffers are cleared in finally block
            while (ob_get_level() > 0) {
                @ob_end_clean();
            }
        }
    }

    /**
     * Get list of dialogs (chats, channels, groups).
     *
     * @return array
     */
    public function getDialogs(): array
    {
        try {
            if (!$this->connected && !$this->connect($this->channelSource)) {
                return [];
            }

            // According to docs: getFullDialogs() returns full dialog info
            // getDialogs() might also work but getFullDialogs() is preferred
            try {
                if (!EventLoop::getDriver()) {
                    EventLoop::run(function () use (&$dialogs) {
                        $dialogsResult = $this->madeline->getFullDialogs();
                        if ($dialogsResult instanceof \Amp\Future) {
                            $dialogs = await([$dialogsResult])[0];
                        } else {
                            $dialogs = $dialogsResult;
                        }
                    });
                } else {
                    $dialogsResult = $this->madeline->getFullDialogs();
                    if ($dialogsResult instanceof \Amp\Future) {
                        $dialogs = await([$dialogsResult])[0];
                    } else {
                        $dialogs = $dialogsResult;
                    }
                }
            } catch (\Exception $e) {
                Log::error("getFullDialogs() failed: " . $e->getMessage());
                throw new \Exception("Failed to fetch dialogs: " . $e->getMessage());
            }

            // Log dialogs structure for debugging
            $firstDialog = null;
            $firstDialogKeys = [];
            if (is_array($dialogs) && !empty($dialogs)) {
                // Handle both indexed and associative arrays
                $firstDialog = is_array($dialogs) ? (array_values($dialogs)[0] ?? null) : null;
                if (is_array($firstDialog)) {
                    $firstDialogKeys = array_keys($firstDialog);
                }
            }
            
            Log::info("getDialogs() - Raw dialogs structure", [
                'channel_id' => $this->channelSource->id,
                'dialogs_type' => gettype($dialogs),
                'is_array' => is_array($dialogs),
                'count' => is_array($dialogs) ? count($dialogs) : 0,
                'is_associative' => is_array($dialogs) && !empty($dialogs) && array_keys($dialogs) !== range(0, count($dialogs) - 1),
                'first_dialog_keys' => $firstDialogKeys,
                'first_dialog_sample' => $firstDialog ? json_encode(array_slice($firstDialog, 0, 20, true)) : null,
                'first_3_dialogs_summary' => is_array($dialogs) && count($dialogs) >= 1 ? array_map(function($d, $idx) {
                    if (!is_array($d)) return ['index' => $idx, 'type' => gettype($d)];
                    return [
                        'index' => $idx,
                        'keys' => array_keys($d),
                        'has_peer' => isset($d['peer']),
                        'has_entity' => isset($d['entity']),
                        'peer_type' => isset($d['peer']) && is_array($d['peer']) ? ($d['peer']['_'] ?? 'unknown') : 'not_array',
                        'peer_keys' => isset($d['peer']) && is_array($d['peer']) ? array_keys($d['peer']) : [],
                    ];
                }, array_slice(array_values($dialogs), 0, 3), array_keys(array_slice(array_values($dialogs), 0, 3))) : [],
            ]);

            $result = [];
            
            // Handle different return structures from MadelineProto
            // getFullDialogs() returns an associative array where keys are dialog IDs
            // Each dialog has a 'peer' field that needs to be resolved
            if (!is_array($dialogs) || empty($dialogs)) {
                Log::warning("getDialogs() - Empty or invalid dialogs", [
                    'channel_id' => $this->channelSource->id,
                ]);
                return [];
            }
            
            // Convert associative array to indexed array if needed
            // getFullDialogs() returns [dialogId => dialog, ...]
            $dialogsArray = array_values($dialogs);
            
            // Collect all peers first
            $peersToResolve = [];
            $dialogPeers = [];
            foreach ($dialogsArray as $index => $dialog) {
                if (!is_array($dialog)) {
                    continue;
                }
                $peer = $dialog['peer'] ?? null;
                if ($peer) {
                    $peersToResolve[$index] = $peer;
                    $dialogPeers[$index] = $dialog;
                }
            }
            
            // Update dialogs to use indexed array
            $dialogs = $dialogsArray;
            
            // Resolve all peers in a single event loop run
            // Try using getPwrChat() which might return entities directly
            $resolvedEntities = [];
            if (!empty($peersToResolve)) {
                try {
                if (!EventLoop::getDriver()) {
                        EventLoop::run(function () use ($peersToResolve, &$resolvedEntities) {
                            $futures = [];
                            foreach ($peersToResolve as $index => $peer) {
                                try {
                                    // Try getPwrChat first (returns full chat info)
                                    $pwrResult = $this->madeline->getPwrChat($peer, false);
                                    if ($pwrResult instanceof \Amp\Future) {
                                        $futures[$index] = $pwrResult;
                                    } else {
                                        $resolvedEntities[$index] = $pwrResult;
                                    }
                                } catch (\Exception $e) {
                                    // Fallback to getInfo if getPwrChat fails
                                    try {
                                        $infoResult = $this->madeline->getInfo($peer);
                                        if ($infoResult instanceof \Amp\Future) {
                                            $futures[$index] = $infoResult;
                                        } else {
                                            $resolvedEntities[$index] = $infoResult;
                                        }
                                    } catch (\Exception $e2) {
                                        Log::warning("Failed to resolve peer", [
                                            'index' => $index,
                                            'getPwrChat_error' => $e->getMessage(),
                                            'getInfo_error' => $e2->getMessage(),
                                        ]);
                                    }
                                }
                            }
                            
                            if (!empty($futures)) {
                                $results = await($futures);
                                foreach ($results as $index => $entity) {
                                    $resolvedEntities[$index] = $entity;
                                }
                            }
                    });
                } else {
                        // Already in event loop, resolve directly
                        foreach ($peersToResolve as $index => $peer) {
                            try {
                                // Try getPwrChat first
                                $pwrResult = $this->madeline->getPwrChat($peer, false);
                                if ($pwrResult instanceof \Amp\Future) {
                                    $resolvedEntities[$index] = await([$pwrResult])[0];
                                } else {
                                    $resolvedEntities[$index] = $pwrResult;
                                }
                            } catch (\Exception $e) {
                                // Fallback to getInfo
                                try {
                                    $infoResult = $this->madeline->getInfo($peer);
                                    if ($infoResult instanceof \Amp\Future) {
                                        $resolvedEntities[$index] = await([$infoResult])[0];
                                    } else {
                                        $resolvedEntities[$index] = $infoResult;
                                    }
                                } catch (\Exception $e2) {
                                    Log::warning("Failed to resolve peer", [
                                        'index' => $index,
                                        'getPwrChat_error' => $e->getMessage(),
                                        'getInfo_error' => $e2->getMessage(),
                                    ]);
                                }
                            }
                        }
                    }
                } catch (\Exception $e) {
                    Log::error("Failed to resolve peers batch", [
                        'channel_id' => $this->channelSource->id,
                        'error' => $e->getMessage(),
                        'trace' => $e->getTraceAsString(),
                    ]);
                }
            }
            
            // Process each dialog with resolved entity
            foreach ($dialogs as $index => $dialog) {
                if (!is_array($dialog)) {
                    continue;
                }

                $entity = null;
                $entityId = null;
                $username = null;
                $title = null;
                $entityType = 'unknown';
                
                // Get resolved entity if we have it
                if (isset($resolvedEntities[$index])) {
                    $entity = $resolvedEntities[$index];
                } elseif (isset($dialog['entity'])) {
                    // Some methods might return entity directly
                    $entity = $dialog['entity'];
                } elseif (isset($dialog['_']) && !isset($dialog['peer'])) {
                    // Dialog might be the entity itself (no peer field)
                    $entity = $dialog;
                } elseif (isset($dialog['peer']) && is_array($dialog['peer'])) {
                    // Check if peer already has entity info embedded
                    // In some MadelineProto versions, peer might contain entity data
                    $peer = $dialog['peer'];
                    if (isset($peer['title']) || isset($peer['username']) || isset($peer['channel_id']) || isset($peer['chat_id'])) {
                        $entity = $peer;
                    } else {
                        // Try to get entity from peer database if available
                        try {
                            $peerId = $peer['channel_id'] ?? $peer['chat_id'] ?? $peer['user_id'] ?? null;
                            if ($peerId && method_exists($this->madeline, 'getInfo')) {
                                // Try to get info from peer database
                                $peerInfo = $this->madeline->getInfo($peer);
                                if ($peerInfo && is_array($peerInfo)) {
                                    $entity = $peerInfo;
                                }
                            }
                        } catch (\Exception $e) {
                            // Ignore - will use peer directly
                        }
                        
                        // If still no entity, use peer as entity (it has the type info)
                        if (!$entity && isset($peer['_'])) {
                            $entity = $peer;
                        }
                    }
                }
                
                // Extract info from entity
                if ($entity && is_array($entity)) {
                    // Use bot_api_id for ID (MadelineProto v8 format)
                    $entityId = $entity['bot_api_id'] ?? $entity['id'] ?? $entity['channel_id'] ?? $entity['chat_id'] ?? $entity['user_id'] ?? null;
                $username = $entity['username'] ?? null;
                $title = $entity['title'] ?? $entity['first_name'] ?? $entity['name'] ?? null;
                    $entityType = $entity['type'] ?? $entity['_'] ?? 'unknown';
                } else {
                    // Fallback: try direct extraction from dialog or peer
                    $entityId = $dialog['id'] ?? $dialog['bot_api_id'] ?? null;
                    $username = $dialog['username'] ?? null;
                    $title = $dialog['title'] ?? null;
                    $entityType = $dialog['type'] ?? $dialog['_'] ?? 'unknown';
                    
                    // If we have a peer but no entity, try extracting ID from peer
                    if (!$entityId && isset($dialog['peer']) && is_array($dialog['peer'])) {
                        $peer = $dialog['peer'];
                        $entityId = $peer['channel_id'] ?? $peer['chat_id'] ?? $peer['user_id'] ?? null;
                        $entityType = $peer['_'] ?? $entityType;
                        
                        // Also try to get title/username from dialog's top_message or other fields
                        if (!$title && isset($dialog['top_message'])) {
                            // Some dialogs might have title in other fields
                            $title = $dialog['top_message']['message'] ?? null;
                        }
                    }
                }
                
                // Final fallback: if we still don't have title but have entityId, try to construct a title
                if (!$title && $entityId) {
                    $title = 'Channel ' . $entityId;
                }
                
                // Log entity info for debugging
                Log::debug("getDialogs() - Processing dialog", [
                    'index' => $index,
                    'has_entity' => !empty($entity),
                    'entity_id' => $entityId,
                    'entity_type' => $entityType,
                    'title' => $title,
                    'username' => $username,
                    'entity_keys' => $entity && is_array($entity) ? array_keys($entity) : [],
                ]);
                
                // Only include channels and groups (not private chats/users)
                // Check entity type more comprehensively - handle all MadelineProto entity types
                $entityTypeLower = strtolower($entityType);
                
                // Check for channel types (channels and supergroups)
                // MadelineProto types: channel, supergroup, Channel, Supergroup, PeerChannel, PeerSupergroup
                $isChannel = strpos($entityTypeLower, 'channel') !== false || 
                            strpos($entityTypeLower, 'supergroup') !== false ||
                            $entityType === 'channel' ||
                            $entityType === 'supergroup' ||
                            $entityType === 'Channel' ||
                            $entityType === 'Supergroup' ||
                            $entityType === 'PeerChannel' ||
                            $entityType === 'PeerSupergroup';
                
                // Check for group types (chats and groups)
                // MadelineProto types: chat, group, megagroup, Chat, Group, Megagroup, PeerChat
                // Note: Exclude 'user' and 'PeerUser' (private chats)
                $isGroup = ($entityTypeLower !== 'user' && strpos($entityTypeLower, 'user') === false) &&
                          (strpos($entityTypeLower, 'chat') !== false || 
                           strpos($entityTypeLower, 'group') !== false ||
                           strpos($entityTypeLower, 'megagroup') !== false ||
                           $entityType === 'chat' ||
                           $entityType === 'group' ||
                           $entityType === 'megagroup' ||
                           $entityType === 'Chat' ||
                           $entityType === 'Group' ||
                           $entityType === 'Megagroup' ||
                           $entityType === 'PeerChat');
                
                // Also check peer type if entity type is unknown or if we haven't determined type yet
                if (($entityType === 'unknown' || (!$isChannel && !$isGroup)) && isset($dialog['peer'])) {
                    $peerType = $dialog['peer']['_'] ?? null;
                    if ($peerType) {
                        $peerTypeLower = strtolower($peerType);
                        // Exclude user/private chats
                        if ($peerTypeLower !== 'peeruser' && strpos($peerTypeLower, 'user') === false) {
                            $isChannel = $isChannel || strpos($peerTypeLower, 'channel') !== false || 
                                        strpos($peerTypeLower, 'supergroup') !== false ||
                                        $peerType === 'PeerChannel' ||
                                        $peerType === 'PeerSupergroup';
                            $isGroup = $isGroup || (strpos($peerTypeLower, 'chat') !== false && strpos($peerTypeLower, 'user') === false) || 
                                      strpos($peerTypeLower, 'group') !== false ||
                                      $peerType === 'PeerChat';
                            if ($entityType === 'unknown') {
                                $entityType = $peerType; // Update entity type from peer
                            }
                        }
                    }
                }
                
                // Additional check: if we have channel_id or chat_id in peer, it's likely a channel/group
                if (!$isChannel && !$isGroup && isset($dialog['peer']) && is_array($dialog['peer'])) {
                    $peer = $dialog['peer'];
                    if (isset($peer['channel_id'])) {
                        $isChannel = true;
                        $entityType = $entityType === 'unknown' ? 'PeerChannel' : $entityType;
                    } elseif (isset($peer['chat_id'])) {
                        $isGroup = true;
                        $entityType = $entityType === 'unknown' ? 'PeerChat' : $entityType;
                    }
                }
                
                // Skip if not a channel or group, or if we don't have an ID
                if (!$entityId) {
                    Log::debug("getDialogs() - Skipping dialog (no ID)", [
                        'index' => $index,
                        'entity_type' => $entityType,
                    ]);
                    continue;
                }
                
                if (!$isChannel && !$isGroup) {
                    Log::debug("getDialogs() - Skipping dialog (not channel/group)", [
                        'index' => $index,
                        'entity_type' => $entityType,
                        'entity_id' => $entityId,
                    ]);
                    continue;
                }

                    $result[] = [
                        'id' => $entityId,
                        'username' => $username,
                    'title' => $title ?: 'Unknown',
                        'type' => $entityType,
                    ];
                }
            
            Log::info("getDialogs() - Processed dialogs", [
                'channel_id' => $this->channelSource->id,
                'total_dialogs' => count($dialogs),
                'filtered_result' => count($result),
                'result_sample' => array_slice($result, 0, 5),
            ]);
            
            // If no results but we have dialogs, log why
            if (empty($result) && !empty($dialogs)) {
                Log::warning("getDialogs() - No channels/groups found despite having dialogs", [
                    'channel_id' => $this->channelSource->id,
                    'total_dialogs' => count($dialogs),
                    'sample_dialogs' => array_map(function($d, $idx) {
                        if (!is_array($d)) return ['index' => $idx, 'type' => gettype($d)];
                        $peer = $d['peer'] ?? null;
                        return [
                            'index' => $idx,
                            'keys' => array_keys($d),
                            'peer' => $peer ? (is_array($peer) ? ['type' => $peer['_'] ?? 'unknown', 'keys' => array_keys($peer)] : gettype($peer)) : null,
                            'entity' => isset($d['entity']) ? 'exists' : 'missing',
                        ];
                    }, array_slice(array_values($dialogs), 0, 5), array_keys(array_slice(array_values($dialogs), 0, 5))),
                ]);
            }

            return $result;

        } catch (\Exception $e) {
            $this->logError("Failed to get dialogs: " . $e->getMessage());
            return [];
        }
    }

    /**
     * Get dialogs in chunks for progressive loading.
     * Caches raw dialogs and processes them in batches.
     *
     * @param int $chunk Chunk number (0-based)
     * @param int $chunkSize Number of dialogs to process per chunk
     * @return array
     */
    public function getDialogsChunked(int $chunk = 0, int $chunkSize = 15): array
    {
        try {
            if (!$this->connected && !$this->connect($this->channelSource)) {
                return [
                    'dialogs' => [],
                    'has_more' => false,
                    'total_loaded' => 0,
                ];
            }

            // Create cache key based on source ID
            $cacheKey = 'telegram_dialogs_' . $this->channelSource->id;
            $cacheKeyTimestamp = $cacheKey . '_timestamp';
            $cacheKeyFetching = $cacheKey . '_fetching';
            $cacheKeyPartial = $cacheKey . '_partial'; // For first batch
            
            // Get raw dialogs from cache
            $cachedRawDialogs = \Illuminate\Support\Facades\Cache::get($cacheKey);
            $cacheAge = \Illuminate\Support\Facades\Cache::get($cacheKeyTimestamp);
            $isFetching = \Illuminate\Support\Facades\Cache::get($cacheKeyFetching);
            $partialDialogs = \Illuminate\Support\Facades\Cache::get($cacheKeyPartial);
            
            // For chunk 0: Return first batch immediately, fetch rest in background
            if ($chunk === 0) {
                // If we have full cache, use it
                if ($cachedRawDialogs !== null && $cacheAge && (time() - $cacheAge) < 3600) {
                    Log::debug("Using cached dialogs for chunk 0");
                } 
                // If we have partial cache (first batch), use it immediately
                elseif ($partialDialogs !== null) {
                    Log::debug("Using partial cached dialogs for chunk 0");
                    $cachedRawDialogs = $partialDialogs;
                }
                // If no cache and not fetching, fetch all dialogs but return first batch immediately
                elseif (!$isFetching) {
                    Log::info("Fetching dialogs for chunk 0 (will return first batch immediately)");
                    
                    // Mark as fetching to prevent duplicate requests (shorter timeout to allow retry)
                    \Illuminate\Support\Facades\Cache::put($cacheKeyFetching, true, 120); // 2 minutes
                    \Illuminate\Support\Facades\Cache::put($cacheKeyFetching . '_since', time(), 120);
                    
                    try {
                        // Note: getFullDialogs() doesn't support pagination - it fetches ALL dialogs
                        // But we'll process and return first batch immediately, cache the rest
                        $startTime = microtime(true);
                        
                        // Set a timeout for the operation (60 seconds max)
                        $timeout = 60;
                        $rawDialogs = null;
                        $fetchError = null;
                        
                        try {
                            if (!EventLoop::getDriver()) {
                                EventLoop::run(function () use (&$rawDialogs, &$fetchError, $timeout) {
                                    try {
                                        $dialogsResult = $this->madeline->getFullDialogs();
                                        if ($dialogsResult instanceof \Amp\Future) {
                                            $rawDialogs = await([$dialogsResult], $timeout * 1000)[0];
                                        } else {
                                            $rawDialogs = $dialogsResult;
                                        }
                                    } catch (\Exception $e) {
                                        $fetchError = $e;
                                    }
                                });
                            } else {
                                $dialogsResult = $this->madeline->getFullDialogs();
                                if ($dialogsResult instanceof \Amp\Future) {
                                    $rawDialogs = await([$dialogsResult], $timeout * 1000)[0];
                                } else {
                                    $rawDialogs = $dialogsResult;
                                }
                            }
                        } catch (\Amp\TimeoutException $e) {
                            Log::error("getFullDialogs() timed out after {$timeout} seconds");
                            $fetchError = new \Exception("Request timed out after {$timeout} seconds. Please try again.");
                        } catch (\Exception $e) {
                            Log::error("getFullDialogs() exception: " . $e->getMessage());
                            $fetchError = $e;
                        }
                        
                        if ($fetchError) {
                            throw $fetchError;
                        }
                        
                        $fetchTime = round((microtime(true) - $startTime) * 1000, 2);
                        // Preserve keys! getFullDialogs() returns associative array where keys are peer IDs
                        $allDialogs = is_array($rawDialogs) ? $rawDialogs : [];
                        
                        Log::info("Fetched " . count($allDialogs) . " dialogs in {$fetchTime}ms", [
                            'is_associative' => !empty($allDialogs) && array_keys($allDialogs) !== range(0, count($allDialogs) - 1),
                            'sample_keys' => array_slice(array_keys($allDialogs), 0, 5),
                        ]);
                        
                        if (empty($allDialogs)) {
                            Log::warning("getFullDialogs() returned empty array");
                            \Illuminate\Support\Facades\Cache::forget($cacheKeyFetching);
                            \Illuminate\Support\Facades\Cache::forget($cacheKeyFetching . '_since');
                            // Don't throw error for empty - user might not have channels
                            $cachedRawDialogs = [];
                        } else {
                            // Cache all dialogs immediately
                            \Illuminate\Support\Facades\Cache::put($cacheKey, $allDialogs, 3600);
                            \Illuminate\Support\Facades\Cache::put($cacheKeyTimestamp, time(), 3600);
                            \Illuminate\Support\Facades\Cache::forget($cacheKeyPartial);
                            \Illuminate\Support\Facades\Cache::forget($cacheKeyFetching);
                            
                            $cachedRawDialogs = $allDialogs;
                        }
                        
                    } catch (\Exception $e) {
                        Log::error("getFullDialogs() failed: " . $e->getMessage(), [
                            'exception' => get_class($e),
                            'trace' => $e->getTraceAsString()
                        ]);
                        // Clear fetching flag so user can retry
                        \Illuminate\Support\Facades\Cache::forget($cacheKeyFetching);
                        // Don't set empty array - let it fall through to return error
                        throw $e;
                    }
                } else {
                    // Background fetch in progress, use partial cache if available
                    if ($partialDialogs !== null) {
                        Log::debug("Background fetch in progress, using partial cache");
                        $cachedRawDialogs = $partialDialogs;
                    } else {
                        // Check if fetching flag is stale (older than 2 minutes)
                        $fetchingSince = \Illuminate\Support\Facades\Cache::get($cacheKeyFetching . '_since');
                        if ($fetchingSince && (time() - $fetchingSince) > 120) {
                            // Stale fetch flag, clear it and allow retry
                            Log::warning("Stale fetching flag detected, clearing it");
                            \Illuminate\Support\Facades\Cache::forget($cacheKeyFetching);
                            \Illuminate\Support\Facades\Cache::forget($cacheKeyFetching . '_since');
                            $cachedRawDialogs = [];
                        } else {
                            // No cache at all, return empty with loading indicator
                            Log::info("No cache available, background fetch in progress");
                            // Return empty but indicate loading state
                            return [
                                'dialogs' => [],
                                'has_more' => false,
                                'total_loaded' => 0,
                                'loading' => true,
                                'message' => 'Loading channels, please wait a moment and refresh...',
                            ];
                        }
                    }
                }
            } else {
                // For other chunks: Use cache if available
                if ($cachedRawDialogs !== null) {
                    Log::debug("Using cached dialogs for chunk {$chunk}");
                } elseif ($partialDialogs !== null) {
                    // Use partial cache as fallback
                    Log::debug("Using partial cached dialogs for chunk {$chunk}");
                    $cachedRawDialogs = $partialDialogs;
                } else {
                    // No cache, return empty
                    $cachedRawDialogs = [];
                }
            }

            if (empty($cachedRawDialogs)) {
                // For chunk 0, if we have no cache and no dialogs, it's an error
                if ($chunk === 0) {
                    // Check if we're in a fetching state (might be in progress)
                    $isFetching = \Illuminate\Support\Facades\Cache::get($cacheKeyFetching);
                    if ($isFetching) {
                        // Fetch in progress, return empty but indicate it's loading
                        return [
                            'dialogs' => [],
                            'has_more' => false,
                            'total_loaded' => 0,
                            'loading' => true,
                            'message' => 'Loading channels, please wait...',
                        ];
                    }
                    // No cache and not fetching - this is an error
                    throw new \RuntimeException('No channels available. Please try refreshing the page or check your Telegram connection.');
                }
                // For other chunks, empty is normal (end of list)
                return [
                    'dialogs' => [],
                    'has_more' => false,
                    'total_loaded' => $chunk * $chunkSize,
                ];
            }

            // Calculate chunk range
            $startIndex = $chunk * $chunkSize;
            $endIndex = min($startIndex + $chunkSize, count($cachedRawDialogs));
            
            // getFullDialogs() returns an associative array where keys are peer IDs
            // We need to preserve both keys and values
            $chunkDialogs = [];
            $keys = array_keys($cachedRawDialogs);
            
            // Verify keys are peer IDs (should start with - for channels/groups, or be positive for users)
            // If keys are numeric indices (0, 1, 2...), the cache structure is wrong - clear it
            if (!empty($keys) && is_numeric($keys[0]) && $keys[0] >= 0 && $keys[0] < 100) {
                Log::warning("Cache structure invalid - keys are numeric indices, not peer IDs. Clearing cache.");
                \Illuminate\Support\Facades\Cache::forget($cacheKey);
                \Illuminate\Support\Facades\Cache::forget($cacheKeyTimestamp);
                \Illuminate\Support\Facades\Cache::forget($cacheKeyPartial);
                return [
                    'dialogs' => [],
                    'has_more' => false,
                    'total_loaded' => 0,
                    'loading' => true,
                    'message' => 'Cache invalid, refreshing...',
                ];
            }
            
            for ($i = $startIndex; $i < $endIndex && $i < count($keys); $i++) {
                $key = $keys[$i];
                $dialog = $cachedRawDialogs[$key];
                // Store dialog with its key (peer ID) for reference
                $chunkDialogs[] = [
                    'dialog' => $dialog,
                    'peer_id' => $key, // The key is the peer ID
                ];
            }
            
            if (empty($chunkDialogs)) {
                return [
                    'dialogs' => [],
                    'has_more' => false,
                    'total_loaded' => $chunk * $chunkSize, // Estimate based on chunk number
                ];
            }

            // Process this chunk
            // For chunk 0, skip peer resolution to speed up initial load (FAST PATH)
            // For chunk 0, we only extract basic info from peer structure without API calls
            // Subsequent chunks will resolve peers for better details
            $skipPeerResolution = ($chunk === 0);
            
            $startTime = microtime(true);
            $processedChunk = $this->processDialogsChunk($chunkDialogs, $startIndex, $skipPeerResolution);
            $processTime = round((microtime(true) - $startTime) * 1000, 2);
            
            Log::debug("Processed chunk {$chunk} in {$processTime}ms (dialogs: " . count($processedChunk) . ", skip_peer_resolution: " . ($skipPeerResolution ? 'yes' : 'no') . ")");

            $hasMore = $endIndex < count($cachedRawDialogs);
            
            // Calculate total loaded based on ACTUAL processed dialogs (channels/groups that passed filtering)
            // This is the actual count, not an estimate
            $totalLoaded = count($processedChunk);

            return [
                'dialogs' => $processedChunk,
                'has_more' => $hasMore,
                'total_loaded' => $totalLoaded,
            ];

        } catch (\Exception $e) {
            $this->logError("Failed to get dialogs chunked: " . $e->getMessage());
            return [
                'dialogs' => [],
                'has_more' => false,
                'total_loaded' => 0,
            ];
        }
    }

    /**
     * Process a chunk of dialogs.
     *
     * @param array $chunkDialogs
     * @param int $startIndex Starting index in the full dialogs array
     * @param bool $skipPeerResolution Skip peer resolution for faster initial load
     * @return array
     */
    protected function processDialogsChunk(array $chunkDialogs, int $startIndex, bool $skipPeerResolution = false): array
    {
        $result = [];
        
        // Collect peers for this chunk
        $peersToResolve = [];
        $peersToResolveForTitle = []; // For lightweight title resolution when skipPeerResolution is true
        $peerIdsForTitle = []; // Store peer_id_from_key for title resolution (works for all chunks)
        
        foreach ($chunkDialogs as $localIndex => $dialogData) {
            // Handle new structure: dialogData contains 'dialog' and 'peer_id'
            if (isset($dialogData['dialog'])) {
                $dialog = $dialogData['dialog'];
                $peerIdFromKey = $dialogData['peer_id'] ?? null;
            } else {
                // Fallback: old structure (direct dialog)
                $dialog = $dialogData;
                $peerIdFromKey = null;
            }
            
            if (!is_array($dialog)) {
                continue;
            }
            
            $peer = $dialog['peer'] ?? null;
            if ($peer && is_array($peer)) {
                $peersToResolve[$localIndex] = $peer;
                // Also collect for title resolution if skipPeerResolution is true
                if ($skipPeerResolution) {
                    $peersToResolveForTitle[$localIndex] = $peer;
                }
            }
            
            // For title resolution, store peer_id_from_key for ALL chunks (can be used directly with getInfo/getPwrChat)
            // According to MadelineProto docs, getInfo() accepts peer IDs, usernames, or peer objects
            // This ensures we can resolve titles even if peer object is missing or incomplete
            if ($peerIdFromKey !== null && $peerIdFromKey !== '') {
                $peerIdsForTitle[$localIndex] = $peerIdFromKey;
            }
        }
        
        // Debug: Log peer collection results
        if ($skipPeerResolution) {
            Log::debug("Peer collection for title resolution", [
                'peersToResolveForTitle_count' => count($peersToResolveForTitle),
                'peerIdsForTitle_count' => count($peerIdsForTitle),
                'peersToResolve_count' => count($peersToResolve),
                'chunkDialogs_count' => count($chunkDialogs),
            ]);
        }

        // Batch resolve peers for title/username
        // This is needed because getFullDialogs() doesn't always include entity info
        // According to MadelineProto docs: getInfo() and getPwrChat() accept peer IDs, usernames, or peer objects
        $resolvedTitles = [];
        // Use peer_ids directly if available (more reliable than peer objects)
        // For chunk 0: use peerIdsForTitle if available, fallback to peer objects
        // For chunk 1+: always use peerIdsForTitle for consistent title resolution
        if ($skipPeerResolution) {
            $peersToResolveForTitle = !empty($peerIdsForTitle) ? $peerIdsForTitle : $peersToResolveForTitle;
        } else {
            // For subsequent chunks, use peer IDs directly (more reliable)
            $peersToResolveForTitle = $peerIdsForTitle;
        }
        
        // Resolve titles for ALL chunks (not just chunk 0)
        if (!empty($peersToResolveForTitle)) {
            try {
                // Use getPwrChat to resolve entities in batch for titles/usernames
                // Fallback to getInfo if getPwrChat fails
                if (!EventLoop::getDriver()) {
                    EventLoop::run(function () use ($peersToResolveForTitle, &$resolvedTitles) {
                        $futures = [];
                        foreach ($peersToResolveForTitle as $index => $peer) {
                            try {
                                // Try getPwrChat first (returns full chat info)
                                $pwrResult = $this->madeline->getPwrChat($peer, false);
                                if ($pwrResult instanceof \Amp\Future) {
                                    $futures[$index] = $pwrResult;
                                } else {
                                    $resolvedTitles[$index] = $pwrResult;
                                }
                            } catch (\Exception $e) {
                                // Fallback to getInfo if getPwrChat fails
                                try {
                                    $infoResult = $this->madeline->getInfo($peer);
                                    if ($infoResult instanceof \Amp\Future) {
                                        $futures[$index] = $infoResult;
                                    } else {
                                        $resolvedTitles[$index] = $infoResult;
                                    }
                                } catch (\Exception $e2) {
                                    // Both failed - log and continue
                                    Log::debug("Failed to resolve peer for title at index {$index}", [
                                        'getPwrChat_error' => $e->getMessage(),
                                        'getInfo_error' => $e2->getMessage(),
                                    ]);
                                }
                            }
                        }
                        
                        if (!empty($futures)) {
                            try {
                                $results = await($futures);
                                foreach ($results as $index => $entity) {
                                    $resolvedTitles[$index] = $entity;
                                }
                            } catch (\Exception $e) {
                                Log::debug("Failed to await futures for title resolution: " . $e->getMessage());
                            }
                        }
                    });
                } else {
                    $futures = [];
                    foreach ($peersToResolveForTitle as $index => $peer) {
                        try {
                            // Try getPwrChat first
                            $pwrResult = $this->madeline->getPwrChat($peer, false);
                            if ($pwrResult instanceof \Amp\Future) {
                                $futures[$index] = $pwrResult;
                            } else {
                                $resolvedTitles[$index] = $pwrResult;
                            }
                        } catch (\Exception $e) {
                            // Fallback to getInfo if getPwrChat fails
                            try {
                                $infoResult = $this->madeline->getInfo($peer);
                                if ($infoResult instanceof \Amp\Future) {
                                    $futures[$index] = $infoResult;
                                } else {
                                    $resolvedTitles[$index] = $infoResult;
                                }
                            } catch (\Exception $e2) {
                                // Both failed - log and continue
                                Log::debug("Failed to resolve peer for title at index {$index}", [
                                    'getPwrChat_error' => $e->getMessage(),
                                    'getInfo_error' => $e2->getMessage(),
                                ]);
                            }
                        }
                    }
                    
                    if (!empty($futures)) {
                        try {
                            $results = await($futures);
                            foreach ($results as $index => $entity) {
                                $resolvedTitles[$index] = $entity;
                            }
                        } catch (\Exception $e) {
                            Log::debug("Failed to await futures for title resolution: " . $e->getMessage());
                        }
                    }
                }
                
                Log::info("Batch resolved " . count($resolvedTitles) . " titles out of " . count($peersToResolveForTitle) . " peers", [
                    'chunk' => $skipPeerResolution ? 0 : 'subsequent',
                    'skipPeerResolution' => $skipPeerResolution,
                ]);
            } catch (\Exception $e) {
                Log::warning("Failed to batch resolve titles: " . $e->getMessage(), [
                    'trace' => $e->getTraceAsString(),
                    'chunk' => $skipPeerResolution ? 0 : 'subsequent',
                ]);
                // Don't fail completely - continue with fallback titles
            }
        } else {
            Log::debug("Skipping batch title resolution - no peers to resolve", [
                'peersToResolveForTitle_empty' => empty($peersToResolveForTitle),
                'skipPeerResolution' => $skipPeerResolution,
                'peerIdsForTitle_count' => count($peerIdsForTitle ?? []),
            ]);
        }

        // Resolve peers for this chunk (skip for chunk 0 to speed up initial load)
        $resolvedEntities = [];
        if (!empty($peersToResolve) && !$skipPeerResolution) {
            try {
                if (!EventLoop::getDriver()) {
                    EventLoop::run(function () use ($peersToResolve, &$resolvedEntities) {
                        $futures = [];
                        foreach ($peersToResolve as $index => $peer) {
                            try {
                                $pwrResult = $this->madeline->getPwrChat($peer, false);
                                if ($pwrResult instanceof \Amp\Future) {
                                    $futures[$index] = $pwrResult;
                                } else {
                                    $resolvedEntities[$index] = $pwrResult;
                                }
                            } catch (\Exception $e) {
                                try {
                                    $infoResult = $this->madeline->getInfo($peer);
                                    if ($infoResult instanceof \Amp\Future) {
                                        $futures[$index] = $infoResult;
                                    } else {
                                        $resolvedEntities[$index] = $infoResult;
                                    }
                                } catch (\Exception $e2) {
                                    // Use peer directly
                                    $resolvedEntities[$index] = $peer;
                                }
                            }
                        }
                        
                        if (!empty($futures)) {
                            $results = await($futures);
                            foreach ($results as $index => $entity) {
                                $resolvedEntities[$index] = $entity;
                            }
                        }
                    });
                } else {
                    // Batch resolve when EventLoop driver exists
                    $futures = [];
                    foreach ($peersToResolve as $index => $peer) {
                        try {
                            $pwrResult = $this->madeline->getPwrChat($peer, false);
                            if ($pwrResult instanceof \Amp\Future) {
                                $futures[$index] = $pwrResult;
                            } else {
                                $resolvedEntities[$index] = $pwrResult;
                            }
                        } catch (\Exception $e) {
                            try {
                                $infoResult = $this->madeline->getInfo($peer);
                                if ($infoResult instanceof \Amp\Future) {
                                    $futures[$index] = $infoResult;
                                } else {
                                    $resolvedEntities[$index] = $infoResult;
                                }
                            } catch (\Exception $e2) {
                                $resolvedEntities[$index] = $peer;
                            }
                        }
                    }
                    
                    // Await all futures at once (batch processing)
                    if (!empty($futures)) {
                        $results = await($futures);
                        foreach ($results as $index => $entity) {
                            $resolvedEntities[$index] = $entity;
                        }
                    }
                }
            } catch (\Exception $e) {
                Log::warning("Failed to resolve peers chunk: " . $e->getMessage());
            }
        }

        // Process each dialog in chunk (reuse logic from getDialogs)
        foreach ($chunkDialogs as $localIndex => $dialogData) {
            // Handle new structure: dialogData contains 'dialog' and 'peer_id'
            if (isset($dialogData['dialog'])) {
                $dialog = $dialogData['dialog'];
                $peerIdFromKey = $dialogData['peer_id'] ?? null;
            } else {
                // Fallback: old structure (direct dialog)
                $dialog = $dialogData;
                $peerIdFromKey = null;
            }
            
            if (!is_array($dialog)) {
                continue;
            }
            
            // Debug: Log peer_id extraction for first few dialogs
            if ($skipPeerResolution && $localIndex < 3) {
                Log::debug("Extracting peer_id", [
                    'localIndex' => $localIndex,
                    'peer_id_from_key' => $peerIdFromKey,
                    'has_dialog' => isset($dialogData['dialog']),
                    'dialogData_keys' => array_keys($dialogData ?? []),
                ]);
            }
            
            // Debug: Log dialog structure for first few dialogs when skipPeerResolution is true
            if ($skipPeerResolution && $localIndex < 3) {
                $peerDebug = null;
                if (isset($dialog['peer']) && is_array($dialog['peer'])) {
                    $peerDebug = [
                        'peer_keys' => array_keys($dialog['peer']),
                        'peer_' => $dialog['peer']['_'] ?? null,
                        'peer_channel_id' => $dialog['peer']['channel_id'] ?? null,
                        'peer_chat_id' => $dialog['peer']['chat_id'] ?? null,
                        'peer_user_id' => $dialog['peer']['user_id'] ?? null,
                    ];
                }
                Log::debug("Dialog structure (skipPeerResolution=true)", [
                    'index' => $localIndex,
                    'dialog_keys' => array_keys($dialog),
                    'has_peer' => isset($dialog['peer']),
                    'has_entity' => isset($dialog['entity']),
                    'peer_id_from_key' => $peerIdFromKey,
                    'peer_details' => $peerDebug,
                ]);
            }
            
            $entity = $resolvedEntities[$localIndex] ?? null;
            $entityId = null;
            $username = null;
            $title = null;
            $entityType = 'unknown';
            $peer = null;
            $peerType = null;
            
            // First, try to use peer_id from key (getFullDialogs returns keys as peer IDs)
            // The key IS the peer ID - use it directly!
            // This is the PRIMARY source when skipPeerResolution is true
            // Check for !== null to handle 0 as a valid (though unlikely) peer ID
            if ($peerIdFromKey !== null && $peerIdFromKey !== '') {
                // The key from getFullDialogs is the peer ID
                // Format: "-1001234567890" for channels, "123456789" for users, etc.
                $entityId = (string)$peerIdFromKey;
                
                // Determine type from peer ID format
                // Negative IDs starting with -100 are channels/supergroups
                // Other negative IDs are groups
                // Positive IDs are users
                $peerIdStr = (string)$peerIdFromKey;
                if (strpos($peerIdStr, '-100') === 0) {
                    $entityType = 'channel'; // Channel or supergroup
                } elseif (strpos($peerIdStr, '-') === 0) {
                    $entityType = 'group'; // Regular group
                } elseif ($peerIdStr === '0' || $peerIdStr === '') {
                    // Invalid peer ID (0 or empty), skip it
                    continue;
                } else {
                    // Positive ID - likely a user, skip it
                    continue;
                }
                
                // When we have peer_id_from_key, try to extract title/username from dialog structure
                // but don't overwrite entityId - it's already set correctly from the key
                if ($skipPeerResolution) {
                    // Get peer structure for additional info
                    if (isset($dialog['peer']) && is_array($dialog['peer'])) {
                        $peer = $dialog['peer'];
                        $peerType = $peer['_'] ?? null;
                        
                        // Verify peer ID matches (sanity check)
                        $peerChannelId = $peer['channel_id'] ?? null;
                        $peerChatId = $peer['chat_id'] ?? null;
                        // Convert peer IDs to full format for comparison
                        // Telegram channel IDs: -100XXXXXXXXXX format
                        // Telegram chat IDs: -XXXXXXXXXX format
                        if ($peerChannelId) {
                            $fullPeerId = '-100' . abs($peerChannelId);
                            if ($fullPeerId != $peerIdFromKey && abs($peerChannelId) != abs($peerIdFromKey)) {
                                // Mismatch, but continue anyway - peer_id_from_key is authoritative
                            }
                        } elseif ($peerChatId) {
                            $fullPeerId = '-' . abs($peerChatId);
                            if ($fullPeerId != $peerIdFromKey && abs($peerChatId) != abs($peerIdFromKey)) {
                                // Mismatch, but continue anyway - peer_id_from_key is authoritative
                            }
                        }
                    }
                    
                    // Try to get title/username from dialog['entity'] if available
                    if (isset($dialog['entity']) && is_array($dialog['entity'])) {
                        $dialogEntity = $dialog['entity'];
                        $username = $dialogEntity['username'] ?? null;
                        $title = $dialogEntity['title'] ?? $dialogEntity['name'] ?? $dialogEntity['first_name'] ?? null;
                        // Don't overwrite entityType if we already determined it from peer_id
                        if ($entityType === 'unknown') {
                            $entityType = $dialogEntity['_'] ?? $dialogEntity['type'] ?? 'unknown';
                        }
                    }
                    
                    // If we still don't have title/username, use batch-resolved entity if available
                    // This is needed because getFullDialogs() doesn't always include entity info
                    if (isset($resolvedTitles[$localIndex]) && is_array($resolvedTitles[$localIndex])) {
                        $resolvedEntity = $resolvedTitles[$localIndex];
                        // Always try to get title from resolved entity if available
                        $resolvedTitle = $resolvedEntity['title'] ?? $resolvedEntity['name'] ?? $resolvedEntity['first_name'] ?? null;
                        if ($resolvedTitle && (!$title || $title === ('Channel ' . $entityId))) {
                            $title = $resolvedTitle;
                            Log::debug("Using resolved title for peer_id {$peerIdFromKey}: {$title}");
                        }
                        if (!$username) {
                            $username = $resolvedEntity['username'] ?? null;
                        }
                    } elseif ($skipPeerResolution && $localIndex < 3) {
                        Log::debug("No resolved title available for index {$localIndex}, peer_id: {$peerIdFromKey}", [
                            'has_resolvedTitles' => isset($resolvedTitles[$localIndex]),
                            'resolvedTitles_count' => count($resolvedTitles),
                            'peersToResolveForTitle_count' => count($peersToResolveForTitle ?? []),
                        ]);
                    }
                }
            }
            
            // Extract entity info (simplified version of getDialogs logic)
            // Only do this if we don't already have entityId from peer_id_from_key
            if (!$entityId) {
                // Priority 1: Use resolved entity if available (from normal peer resolution for chunk 1+)
                if ($entity && is_array($entity)) {
                    $entityId = $entity['bot_api_id'] ?? $entity['id'] ?? $entity['channel_id'] ?? $entity['chat_id'] ?? $entity['user_id'] ?? null;
                    $username = $entity['username'] ?? null;
                    $title = $entity['title'] ?? $entity['first_name'] ?? $entity['name'] ?? null;
                    $entityType = $entity['type'] ?? $entity['_'] ?? 'unknown';
                } 
                // Priority 2: For skipPeerResolution, check dialog['entity'] first (getFullDialogs provides this)
                elseif ($skipPeerResolution && isset($dialog['entity']) && is_array($dialog['entity'])) {
                    $dialogEntity = $dialog['entity'];
                    $entityId = $dialogEntity['bot_api_id'] ?? $dialogEntity['id'] ?? $dialogEntity['channel_id'] ?? $dialogEntity['chat_id'] ?? $dialogEntity['user_id'] ?? null;
                    $username = $dialogEntity['username'] ?? null;
                    $title = $dialogEntity['title'] ?? $dialogEntity['name'] ?? $dialogEntity['first_name'] ?? null;
                    $entityType = $dialogEntity['_'] ?? $dialogEntity['type'] ?? 'unknown';
                    
                    // Also get peer for type detection
                    if (isset($dialog['peer']) && is_array($dialog['peer'])) {
                        $peer = $dialog['peer'];
                        $peerType = $peer['_'] ?? null;
                    }
                } 
                // Priority 3: Extract from peer structure (when skipPeerResolution is true)
                elseif ($skipPeerResolution && isset($dialog['peer']) && is_array($dialog['peer'])) {
                    // For chunk 0, extract basic info from peer without resolution (FAST PATH)
                    $peer = $dialog['peer'];
                    $peerType = $peer['_'] ?? '';
                    
                    // Extract ID from peer - check all possible ID fields
                    // Note: getFullDialogs() returns peer structures like PeerChannel, PeerChat, PeerUser
                    if (isset($peer['channel_id'])) {
                        $entityId = $peer['channel_id'];
                    } elseif (isset($peer['chat_id'])) {
                        $entityId = $peer['chat_id'];
                    } elseif (isset($peer['user_id'])) {
                        $entityId = $peer['user_id'];
                    }
                    
                    // Also check if ID is in dialog itself (some structures have it there)
                    if (!$entityId) {
                        $entityId = $dialog['id'] ?? $dialog['channel_id'] ?? $dialog['chat_id'] ?? null;
                    }
                    
                    // Determine type from peer - use the peer type directly for better matching
                    $peerTypeLower = strtolower($peerType);
                    if (strpos($peerTypeLower, 'channel') !== false || strpos($peerTypeLower, 'supergroup') !== false) {
                        $entityType = 'channel';
                    } elseif (strpos($peerTypeLower, 'chat') !== false || strpos($peerTypeLower, 'group') !== false || strpos($peerTypeLower, 'megagroup') !== false) {
                        $entityType = 'group';
                    } else {
                        // Fallback: use peer type as-is
                        $entityType = $peerType ?: 'unknown';
                    }
                    
                    // Try to get title from dialog - check multiple possible locations
                    // Note: getFullDialogs() might not include entity field, so we need to resolve later
                    $title = $dialog['entity']['title'] ?? 
                            $dialog['entity']['name'] ?? 
                            $dialog['title'] ?? 
                            $dialog['name'] ?? 
                            null;
                    
                    // Try to get username from dialog if available
                    if (empty($username)) {
                        $username = $dialog['entity']['username'] ?? 
                                   $dialog['username'] ?? 
                                   null;
                    }
                }
            } elseif (isset($dialog['peer']) && is_array($dialog['peer'])) {
                $peer = $dialog['peer'];
                $peerType = $peer['_'] ?? 'unknown';
                $entityId = $peer['channel_id'] ?? $peer['chat_id'] ?? $peer['user_id'] ?? null;
                // Also check dialog itself
                if (!$entityId) {
                    $entityId = $dialog['id'] ?? $dialog['channel_id'] ?? $dialog['chat_id'] ?? null;
                }
                $entityType = $peerType; // Use peer type directly
            }
            
            // If we still don't have entityId, try to extract from dialog structure directly
            if (!$entityId && isset($dialog['entity']) && is_array($dialog['entity'])) {
                $entityId = $dialog['entity']['id'] ?? 
                           $dialog['entity']['bot_api_id'] ?? 
                           $dialog['entity']['channel_id'] ?? 
                           $dialog['entity']['chat_id'] ?? 
                           null;
                if (!$title && isset($dialog['entity'])) {
                    $title = $dialog['entity']['title'] ?? $dialog['entity']['name'] ?? null;
                }
                if (!$username && isset($dialog['entity'])) {
                    $username = $dialog['entity']['username'] ?? null;
                }
                if ($entityType === 'unknown' && isset($dialog['entity']['_'])) {
                    $entityType = $dialog['entity']['_'];
                }
            }
            
            // Final fallback: use peer_id from key if available (getFullDialogs keys are peer IDs)
            if (!$entityId && $peerIdFromKey) {
                $entityId = $peerIdFromKey;
            }
            
            if (!$entityId) {
                Log::debug("Skipping dialog - no entity ID", [
                    'dialog_keys' => array_keys($dialog ?? []),
                    'peer_id_from_key' => $peerIdFromKey ?? null,
                    'has_peer' => isset($dialog['peer']),
                ]);
                continue;
            }
            
            // Check if channel/group - improved detection
            $entityTypeLower = strtolower($entityType ?? '');
            
            // Get peer if not already set
            if (!$peer && isset($dialog['peer']) && is_array($dialog['peer'])) {
                $peer = $dialog['peer'];
                if (isset($peer['_'])) {
                    $peerType = $peer['_'];
                }
            }
            
            // If we already determined type from peer_id key, use it
            $isChannel = false;
            $isGroup = false;
            
            if ($entityType === 'channel') {
                $isChannel = true;
            } elseif ($entityType === 'group') {
                $isGroup = true;
            } else {
                // Try to determine from entity type string
                if (strpos($entityTypeLower, 'channel') !== false || strpos($entityTypeLower, 'supergroup') !== false) {
                    $isChannel = true;
                } elseif ((strpos($entityTypeLower, 'chat') !== false || 
                          strpos($entityTypeLower, 'group') !== false || 
                          strpos($entityTypeLower, 'megagroup') !== false) &&
                         strpos($entityTypeLower, 'user') === false &&
                         strpos($entityTypeLower, 'channel') === false) {
                    $isGroup = true;
                }
                
                // Try to determine from peer structure
                if (!$isChannel && !$isGroup && $peer) {
                    if (isset($peer['channel_id']) && !isset($peer['chat_id']) && !isset($peer['user_id'])) {
                        $isChannel = true;
                    } elseif (isset($peer['chat_id']) && !isset($peer['channel_id']) && !isset($peer['user_id'])) {
                        $isGroup = true;
                    } elseif (isset($peer['_'])) {
                        $peerTypeLower = strtolower($peer['_']);
                        if (strpos($peerTypeLower, 'channel') !== false || strpos($peerTypeLower, 'supergroup') !== false) {
                            $isChannel = true;
                        } elseif ((strpos($peerTypeLower, 'chat') !== false || 
                                  strpos($peerTypeLower, 'group') !== false || 
                                  strpos($peerTypeLower, 'megagroup') !== false) &&
                                 strpos($peerTypeLower, 'user') === false &&
                                 strpos($peerTypeLower, 'channel') === false) {
                            $isGroup = true;
                        }
                    }
                }
                
                // Final fallback: determine from entity ID format
                if (!$isChannel && !$isGroup && $entityId) {
                    $idStr = (string)$entityId;
                    // Telegram channel/group IDs: -100XXXXXXXXXX = channels, -XXXXXXXXXX = groups
                    if (strpos($idStr, '-100') === 0) {
                        $isChannel = true;
                        Log::debug("Detected channel from ID format", ['entity_id' => $entityId]);
                    } elseif (strpos($idStr, '-') === 0 && strlen($idStr) > 10) {
                        $isGroup = true;
                        Log::debug("Detected group from ID format", ['entity_id' => $entityId]);
                    }
                }
            }
            
            if (!$isChannel && !$isGroup) {
                Log::debug("Skipping dialog - not a channel or group", [
                    'entity_id' => $entityId,
                    'entity_type' => $entityType,
                    'peer_type' => $peerType ?? null,
                    'peer_id_from_key' => $peerIdFromKey ?? null,
                ]);
                continue;
            }
            
            // Final check: Use resolved title if available (for all chunks, not just chunk 0)
            // This ensures titles are used even if they weren't extracted from dialog structure
            if (isset($resolvedTitles[$localIndex]) && is_array($resolvedTitles[$localIndex])) {
                $resolvedEntity = $resolvedTitles[$localIndex];
                $resolvedTitle = $resolvedEntity['title'] ?? $resolvedEntity['name'] ?? $resolvedEntity['first_name'] ?? null;
                if ($resolvedTitle && (!$title || $title === ('Channel ' . $entityId))) {
                    $title = $resolvedTitle;
                    if ($localIndex < 3 || !$skipPeerResolution) {
                        Log::debug("Using resolved title (final check) for peer_id {$peerIdFromKey}: {$title}");
                    }
                }
                if (!$username) {
                    $username = $resolvedEntity['username'] ?? null;
                }
            }
            
            $result[] = [
                'id' => $entityId,
                'username' => $username,
                'title' => $title ?: ('Channel ' . $entityId),
                'type' => $entityType,
            ];
        }

        return $result;
    }

    /**
     * Get MadelineProto instance (for use in jobs).
     *
     * @return \danog\MadelineProto\API|null
     */
    public function getMadeline()
    {
        return $this->madeline;
    }

    /**
     * Disconnect from Telegram.
     *
     * @return void
     */
    public function disconnect(): void
    {
        if ($this->madeline) {
            try {
                $this->madeline->stop();
            } catch (\Exception $e) {
                // Ignore errors on disconnect
            }
            $this->madeline = null;
        }
        $this->connected = false;
    }
}


